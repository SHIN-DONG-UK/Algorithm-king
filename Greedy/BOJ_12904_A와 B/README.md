## 💡 BOJ 12904 - A와 B [[문제 링크](https://www.acmicpc.net/problem/12904)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Greedy` |
| 사용 알고리즘 | |
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다
- 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다
   - 문자열의 뒤에 A를 추가한다
   - 문자열을 뒤집고 뒤에 B를 추가한다
- 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하라

**[제약 사항]**

- 1<=S의 길이<=999
- 2<=T의 길이<=1,000
- S의 길이 < T의 길이

### 🔍 풀이 접근
- 두 가지 연산을 Brute-Force하게 해보면 S -> T 여부를 알 수 있긴 하다
- 근데 최악의 경우 S가 1이고, T가 1000이라고 하자
- 그럼 2^1000번의 경우의 수가 나와 TLE가 발생한다
- Brute-Force하게 하지 않고도 경우의 수를 따질 수 있다는 이야기다
- 규칙에 문제를 해결할 열쇠가 있는 것 같다
- 아니면 가지치기로 가능한가?
- 아니면 T -> S 역방향으로 생각해보는 건 어떤가?
- 역방향으로 생각하면 유일해진다

### 💡 핵심 로직
- T의 길이가 S의 길이와 같을 때까지 연산을 반복한다
- T의 끝이 A이면 A를 삭제한다
- T의 끝이 B이면 B를 삭제하고 뒤집는다

### 📌 배운 점
- 문제를 풀이하는 방향성을 틀면 해법이 보인다는 것을 배웠습니다.
- 두 가지 연산이 유일해진다는 것은 곧 그리디함을 이해했습니다.

