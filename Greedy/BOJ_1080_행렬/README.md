## 💡 BOJ 1080 - 행렬 [[문제 링크](https://www.acmicpc.net/problem/1080)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `그리디` |
| 사용 알고리즘 | `그리디` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 이해]**

- 0과 1로만 이루어진 행렬 A와 행렬 B가 있다
- 행렬 A -> 행렬 B로 바꾸는데 필요한 연산 횟수 최솟값을 구하라
- 행렬을 변환하는 연산은 어떤 3x3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것

**[제약 사항]**

- 행렬의 크기 N x M
- N, M <= 50
- A->B가 안되면 -1을 출력할 것

### 🔍 풀이 접근
- 일단 왼쪽위 모서리를 기준점으로 하는 3x3 부분 행렬을 뒤집는 함수를 만들어보자
- 이 함수를 이용해 brute-force하게 접근하면 될라나?
- 최대 50 x 50이라 한 단계에서 시간복잡도는 2,500
- 근데 언제 재귀를 멈출지 기준이 안보인다
- 바꿀 수 없다는 걸 어떻게 정의해야하지?
- 같은 자리를 여러 번 뒤집는건 의미가 없다
- 그런데 0번 자리를 뒤집었다가 1번자리를 뒤집고 다시 0번 자리를 뒤집는건?
  - 0번 자리를 뒤집고, 1번 자리를 뒤집은 다음 다시 0번 자리를 뒤집을 일은 없다
  - 왜냐하면 1번 자리에서 뒤집는게 0번 자리에 영향을 주지 않기 때문
  - 따라서 한 번 뒤집고 넘어가는게 최적이다
  - 즉, 그리디하게 뒤집은 다음 검사해서 같은지 확인하면 된다
  - (i ,j) 하나만 신경쓰면 쉽게 이해된다

### 💡 핵심 로직
- 그리디하게 검사해서 뒤집는다

### 📌 배운 점
- 2차원 격자에서 최적해가 그리디하게 결정되는 문제를 풀이했습니다.
- 그리디의 필연성에 대해 이해했습니다.
