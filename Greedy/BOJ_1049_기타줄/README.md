## 💡 BOJ 1049 - 보물 [[문제 링크](https://www.acmicpc.net/problem/1049)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | Greedy |
| 사용 알고리즘 | Greedy |
| 난이도 | 실버4 |

### ✅ 문제 설명
**[상황]**
- N개의 기타줄이 끊어짐
- 6개짜리 세트 or 낱개

**[입력]**
- 끊어진 기타줄 N, 기타줄 브랜드 수 M (1≤N≤100, 1≤M≤50)
- 세트 가격 a, 낱개 가격 b (0≤a,b≤1000)

**[출력]**
- 적어도 N개를 사기 위해 필요한 돈의 최소를 구하라
- N개를 넘어도 되겠네? -> 세트로 사면 넘을 수 있으니까

### 🔍 풀이 접근
- 세트 + 낱개 조합이 세트만 or 낱개만보다 더 쌀 수 있음.

- 처음에 세트로만 다 사고, 세트랑 낱개랑 바꿔치기하면서 최솟값 찾으면 됨.

### 💡 핵심 로직
```cpp
void solve(){
    // 세트 + 낱개 조합으로 가장 싼 거 찾으면 됨
    // 일단 세트로 다사
    int cnt = N/6; // 세트 개수
    ans = cnt * set_price;
    
    if(N%6 != 0) {
        ans += set_price;
        cnt++;
    }
    
    int now = 6 * cnt; // 갖고있는 개수
    
    int tmp = ans; // 임시 비용
    
    for(int i=0; i<cnt; i++){
        now -= 6;
        tmp -= set_price;
        
        tmp += abs(now - N) * not_price;
        now += abs(now - N);
        
        if(ans > tmp) ans = tmp;
    }
}
```

### 📌 배운 점
- 일단 세트로 다 사고, 그리디하게 세트와 낱개 가격 비교를 통해 업데이트하는 그리디 알고리즘을 이해했습니다.
