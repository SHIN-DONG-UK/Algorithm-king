## 💡 BOJ 1931 - 회의실 배정 [[문제 링크](https://www.acmicpc.net/problem/1931)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | 회의실 배정 문제 |
| 사용 알고리즘 | Greedy |
| 난이도 | 골드5 |

### ✅ 문제 설명
- 한 개의 회의실이 있음.

- N개의 회의에 대해 사용표를 만들고자 함.

- 각 회의 I에 대해 시작시간과 종료 시간이 주어짐.

- 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾고자 함.

- 회의는 한 번 시작하면 중단될 수 없고, 한 회의가 끝나는 동시에 다른 회의 시작 가능.

### 🔍 풀이 접근
- `종료 시간을 기준`으로 오름차순 정렬한다.

- 시작 시간과 종료 시간이 같다고 생각해보자. 종료 시간이 빠른 순으로 회의를 잡으면 최대한 많은 회의를 잡을 수 있음.

- 이제 첫 번째 회의는 무조건 잡는다.

- 그리고 얘의 종료 시간을 기록해두고 얘보다 시작시간이 크거나 같은 회의를 그리디하게 잡는다.

- 단, 종료 시간이 같은 경우 시작 시간이 내림차순이어야 더 많은 회의를 잡을 수 있다.


### 💡 핵심 로직
```cpp
void simulation() {
    int time = meetings[0].end;
    ans = 1;

    for(int i=1; i<N; i++){
        if(meetings[i].start >= time){
            ans++;
            time = meetings[i].end;
        }
    }
}
```

### 📌 배운 점
- 시작 시간과 종료 시간이라는 두 가지 상태를 정렬하여 그리디하게 처리하면 최적해를 구할 수 있음을 알게 되었습니다.

