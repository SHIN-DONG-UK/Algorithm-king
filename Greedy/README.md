# 그리디(Greedy) 알고리즘
>그리디 알고리즘을 한 마디로 표현하면 "**당장 좋은 것만 선택하는 알고리즘**"입니다.

 즉, 현재의 선택이 나중에 끼칠 영향을 고려하지 않습니다.

예를 들어, **자연수 11**에

1. 수에 2 나누기
2. 수에 1 빼기

를 할 수 있다고 하겠습니다. 

11이 1이 될 때까지 연산을 수행한다고 할 때, 가장 적은 연산을 수행하는 방법은 무엇일까요? 직관적으로, "**일단 11을 최대한 2로 나누고**, 2로 나누어지지 않으면 1을 뺀다"는 방법이면 될 것 같습니다.

컴퓨터한테 이런 방법을 이해시키기 위해, 다음의 코드를 작성할 수 있습니다.
```cpp

while(무한반복할건데 1이 되면 멈춰)
{
	if(2로 나누어 떨어지면)
    	2로 나눠
    else
    	1을 빼
}
```

이것이 바로 그리디 알고리즘입니다. 

연산을 한 번 수행하는 것을 **sub task**라고 한다면, sub task마다 일관되게 좋은 것을 선택하는 방법이라고 할 수 있습니다.

### 예시 문제 : 회의실 배정
한 개의 회의실이 있습니다. 이를 이용하고자 하는 N개의 회의가 있습니다. 각 회의는 시작 시간(s)과 종료 시간(f)이 주어지고, 회의 시간이 겹치지 않게 회의실을 이용할 수 있는 최대 회의 개수를 구하고자 합니다.

단,
1. 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
2. 회의 시작 시간과 종료 시간이 같을 수 있다.

위 문제를 해결하는 알고리즘은 "최대한 빨리 끝나는 회의를 우선 선택한다"입니다. 즉, 그리디 알고리즘입니다.

![](https://velog.velcdn.com/images/ehd2610/post/b873bf19-a80d-43b8-aca1-431a271dc4de/image.png)


왜 그럴까요? 일단 **타임 테이블이 최대한 빽빽**하기만 하면, 문제가 원하는 해답입니다. 

각 회의의 종료 시간을 기준으로 오름차순 정렬되어 있다고 해보겠습니다. **정렬된 회의 중 첫 번째 회의는 무조건 선택**해야 합니다. 가장 일찍 끝난 회의이므로, 이 회의를 선택하는 것이 **나머지 회의에게 가장 긴 회의실 이용 시간을 보장**합니다.

이젠 어떻게 할까요? **회의가 시작 가능(이전 회의 종료 시간보다 현재 시작 시간이 크거나 같음)하면 무조건 회의실을 배정**하는 것입니다. 왜냐하면 이 회의를 선택하는 것이 나머지 회의에게 가장 긴 회의실 이용 시간을 보장하기 때문입니다.

어떤가요? 같은 문제를 반복해서 해결하고 있는 것 같지 않나요?

사실 이 문제는 앞의 숫자 연산 문제와 크게 다를게 없습니다.

```cpp
while(회의가 없을 때까지)
{
	if(회의 가능?)
    	선택
    else
    	선택 안해
}
```

여기서 `회의 가능?`이라는 조건은 다음과 같습니다.
```cpp
if(이전에 선택된 회의의 종료시간 <= 현재 회의의 시작 시간)
```

단, 시작 시간과 종료 시간이 같은 회의가 존재하기 때문에 종료 시간이 같은 회의가 여러 개인 경우, 이들 끼리 시작 시간 기준으로 오름차순 정렬되있어야 최적해를 보장합니다.