## 💡 BOJ 20922 - 겹치는 건 싫어 [[문제 링크](https://www.acmicpc.net/problem/20922)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Greedy` |
| 사용 알고리즘 | `두 포인터` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- 같은 원소가 K개 이하로 들어 있는 최장 연속 부분 수열의 길이를 구하라

**[제약 사항]**

- 각 수열은 100,000이하의 자연수
- 길이 N <= 200,000
- 같은 원소 개수 K <= 100

### 🔍 풀이 접근
- 모든 인덱스를 시작점으로 해본다
- 시작점에서 1개부터 N - 시작점 개만큼 해본다
- 거기서 가장 긴 값을 업데이트한다
- Brute-Force하게 접근하면 시간복잡도는 O(N^2)이다
- TLE난다

- 투 포인터로 문제를 해결할 수 있지 않을까?
- 투 포인터를 쓰면 시간복잡도는 O(N)이잖슴
- 0번 인덱스에서 p1, p2를 시작한다
- p2가 k개 이하일 때까지 계속 늘린다
- 만약 p2위치에서 k개 초과나면, p1을 옮기면서 k개 초과 안날때까지 옮긴다
- k개 초과 해결했으면 다시 p2를 올린다
- 이때 길이의 최댓값을 update해둔다
- 길이는 계속 관리하고 있는다

### 💡 핵심 로직
- 두 개의 포인터를 활용해 그리디하게 최댓값을 찾는다

### 📌 배운 점
- 투 포인터 기법을 사용해 시간복잡도 안에서 최적해를 구하는 연습을 했습니다.
- 투 포인터 또한 그리디한 접근 방법임을 이해했습니다.

