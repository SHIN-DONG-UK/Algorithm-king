## 💡 BOJ 14916 - 거스름돈 [[문제 링크](https://www.acmicpc.net/problem/14916)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | Greedy |
| 사용 알고리즘 | Greedy |
| 난이도 | 실버5 |

### ✅ 문제 설명
- `2`원짜리 동전, `5`원짜리 동전이 있음

- 동전의 개수가 최소가 되도록 거슬러 주자

- 거스름돈이 `n`일 때, 동전 개수 최소를 구하라

- 거슬러 줄 수 없으면 `-1`을 출력

### 🔍 풀이 접근
- 2원과 5원은 공약수 관계가 아니라서 5원 거슬러주고 2원 거슬러주면, 거슬러 줄 수 있는데 거슬러 줄 수 없다는 결과가 나올 수 있음

```
예
16

5 5 5 (1) <- 안됨!

5 5 2 2 2 <- 사실 됨>

```

- 일단 5원 최대한 거슬러주고, 안돼? 일단 5원 빼고 2원 넣어

- 그래도 안돼? 그럼 -1

### 💡 핵심 로직
```cpp
void solve(){
    // 1. 5원 올인
    int cnt = n / 5;
    
    if(n%5 != 0) cnt++;
    else {
        // 나누어 떨어지면 여기서 끝내
        // 이게 젤 최소임
        ans = cnt;
        return;
    }
    
    int now = 5 * cnt;
    int len = cnt;
    
    // 2. 5원 하나 빼고 2원이 가능한지 검사
    for(int i=0; i<len; i++){
        cnt -= 1;
        now -= 5;
        
        // 2원이 가능한 순간 끝내
        // 그게 최소야
        if(abs(n-now) % 2 == 0){
            cnt += abs(n-now) / 2;
            now = n;
            
            ans = cnt;
            return;
        }
    }
}
```

### 📌 배운 점
- 기타줄 문제처럼 일단 큰 걸로 올인하고 하나씩 빼면서 최적해를 찾는 그리디 문제 유형을 익혔습니다.

