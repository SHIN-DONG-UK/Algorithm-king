# 1. 이해

```
[구슬 탈출]
- 직사각형 보드
- 안에 빨간 구슬과 파란 구슬
- 빨간 구슬을 빼내는 게임

[직사각형 보드]
- 가장 바깥 행과 열은 모두 막혀있음
- 구멍이 하나 있음
- 빨간 구슬, 파란 구슬 각각 하나씩 존재
- 파란 구슬은 구멍에 들어가면 안됨

[구슬 움직이기]
- 왼쪽, 오른쪽, 위쪽, 아래쪽으로 기울이기
- 빨간 구슬이 구멍에 빠지면 성공
- 파란 구슬이 구멍에 빠지면 실패
- 동시에 빠져도 실패
- 빨간 구슬과 파란 구슬은 같은 칸에 있을 수 없음
- 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때까지

[출력]
- 보드의 상태가 주어졌을 떄, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력
- 만약 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1

[입력]
- N, M(3 <= N,M <= 10)
- 보드 정보
	'.' : 빈칸
	'#' : 벽 -> 구슬 이동 X
	'O' : 구멍
	'R' : 빨간 구슬
	'B' : 파란 구슬
```

# 2. 설계

```
- 일단 어떻게 기울여야 할지를 알려주는 함수가 있다고 하자
- 이 함수에 맵을 주면 몇 번 기울여야 하는지 알려준다

- B는 일단 나중에 생각하고, R만 있다고 해보자
- R에서 시작해서 4방향으로 탐색을 시작한다
- 4방향으로 너비 우선 탐색을 진행해야 최단을 찾을 수 있다
- 근데 이 BFS는 해당 방향으로 벽을 만날 때까지 직진한다
- 그리고 나서 다음 노드를 찾을 수 있다
#######
#R....#
#.....#
#.....#
#....O#
#######

이러한 맵이 있을 때, R이 방향을 탐색하는 노드의 위치(X)는
#######
#R...X#
#.....#
#.....#
#X...O#
#######
이다

1. 위 탐색을 수행하는 함수를 작성해보자

이제 이 함수로 최소'기울이기' 경로 탐색을 할 수 있다
왜냐하면 너비 우선으로 탐색하므로 가장 빠르게 도착하는게 먼저 정답을 선점하기 때문이다

이 함수를 테스트 해보자
(입력)
7 7
#######
#...R.#
#.#####
#.....#
#####.#
#O....#
#######

(visited)
# # # # # # #
# x . . R . #
# . # # # # #
# . . . . . #
# # # # # . #
# O . . . . #
# # # # # # #

# # # # # # #
# . . . R x #
# . # # # # #
# . . . . . #
# # # # # . #
# O . . . . #
# # # # # # #

# # # # # # #
# . . . R . #
# . # # # # #
# x . . . . #
# # # # # . #
# O . . . . #
# # # # # # #

# # # # # # #
# . . . R . #
# . # # # # #
# . . . . x #
# # # # # . #
# O . . . . #
# # # # # # #

# # # # # # #
# . . . R . #
# . # # # # #
# . . . . . #
# # # # # . #
# O . . . x #
# # # # # # #

# # # # # # #
# . . . R . #
# . # # # # #
# . . . . . #
# # # # # . #
# x . . . . #
# # # # # # #

0 0 0 0 0 0 0
0 2 0 0 1 2 0
0 0 0 0 0 0 0
0 3 0 0 0 4 0
0 0 0 0 0 0 0
0 6 0 0 0 5 0
0 0 0 0 0 0 0

잘 나온다

(입력)
10 10
##########
#R#...##.#
#...#.##.#
#####.##.#
#......#.#
#.######.#
#.#....#.#
#.#.#.#..#
#...#.O#.#
##########

# # # # # # # # # #
# R # . . . # # . #
# x . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . x # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # x . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . x # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . x . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# x . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . x # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# x . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . . # . #
# . # . # . # . . #
# . . x # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # x . . . # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

# # # # # # # # # #
# R # . . . # # . #
# . . . # . # # . #
# # # # # . # # . #
# . . . . . . # . #
# . # # # # # # . #
# . # . . . x # . #
# . # . # . # . . #
# . . . # . O # . #
# # # # # # # # # #

0 0 0 0 0 0 0 0 0 0
0 1 0 4 0 5 0 0 0 0
0 2 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 7 0 0 0 6 7 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 10 0 0 11 0 0 0
0 0 0 0 0 0 0 0 0 0
0 8 0 9 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

방문처리 되지 않았으므로 여기는 도달할 수 없다

2. B가 있는 걸 고려해보자
B의 결과를 실시간 반영하여 BFS하면 된다
즉, B가 있는걸 고려해서 움직이는 move함수를 정의하고, 이 move함수에 의해
리턴된 노드를 BFS하면 된다

다시 말하면, BFS라는 껍데기에 move함수를 구현해서 집어넣으면 된다

3. 주의할 점
- 방문처리가 중요하다
- R의 위치는 같지만 B의 위치가 다른 경우, 노드는 구분되어야 한다
- 따라서 R의 위치 + B의 위치 visited배열이 필요하다
- visited[11][11][11][11]의 4차원 배열을 선언하면 됨
```