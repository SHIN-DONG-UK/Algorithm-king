## 💡 BOJ 12852 - 1로 만들기 2 [[문제 링크](https://www.acmicpc.net/problem/12852)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `그래프 탐색` |
| 사용 알고리즘 | `BFS` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지
  1. X가 3으로 나누어 떨어지면, 3으로 나눈다
  2. X가 2로 나누어 떨어지면, 2로 나눈다.
  3. 1을 뺀다.

- 정수 N이 주어졌을 때, 위 세 개의 연산으로 1을 만들거임
- 연산 사용횟수의 최솟값을 구하는 문제

**[제약 사항]**

- 1 <= N <= 1,000,000
- 첫째 줄에 최솟값 출력
- 둘째 줄에 그 숫자까지 가는 숫자들을 출력

### 🔍 풀이 접근
- 최대한 3으로 나누고, 그 다음 2로 나누고, 안되면 1을 빼는 그리디 방법이 최선 아닐까?
- 그런데 10을 그리디하게 해보면 최적해가 안됨
- 완전 탐색으로 풀 수 있지 않나?
  - 매번 3개를 다 시도해보고, 1이 되는 순간 루프를 빠져나가는 방식
  - 가상의 그래프가 존재한다고 생각하고 그래프 탐색하듯이 풀면 될 듯

### 💡 핵심 로직
- 각 숫자들 사이에는 가상의 간선이 존재한다고 생각하자
- 그리고 이 그래프에서 BFS 탐색해서 depth가 최소인 경로를 찾으면 된다
- 경로는 p 배열에 담아놓는다

### 📌 배운 점
- 그리디 알고리즘이 안된다는 것을 확인하고, 완전 탐색으로 문제를 접근했습니다.
- 부모 배열을 둬서 시작점에서 경로를 추적할 수 있도록 했습니다.