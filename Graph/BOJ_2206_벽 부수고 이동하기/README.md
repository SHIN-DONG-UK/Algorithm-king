## 💡 BOJ 2206 - 벽 부수고 이동하기 [[문제 링크](https://www.acmicpc.net/problem/2206)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `그래프 탐색` |
| 사용 알고리즘 | `BFS (Flood Fill)` |
| 난이도 | 골드3 |

### ✅ 문제 설명
- N x M 맵이 있고, (1, 1)에서 시작해서 (N, M)에 도착해야 함

- `1`은 벽, `0`은 빈 칸이고 벽은 지날 수 없음

- 최단거리로 이동하고 싶은데, 벽을 `한 번` 부수고 이동할 수 있음

- **최단거리를 출력하라. 만약 이동할 수 없으면 -1 출력**

### 🔍 풀이 접근
- 벽 부수기를 고려하지 않으면 단순한 Flood Fill 문제이지만, 벽을 부술 수 있다는 것을 고려해야 함

- 노드에 벽을 부순 상태를 저장하는 방법을 생각할 수 있다

- 어떤 노드에서 벽을 부쉈으면, 더이상 이 노드에 의한 인접 그래프 탐색은 벽을 부술 수 없다

### 💡 핵심 로직
- 언제 벽을 부술 것인가?
	- 부순적이 없으면 부수면 된다

- 벽을 부수고 이동한 위치에 방문처리를 하면 그 이후에 오는 애들은 방문이 안될텐데?
	- 경로를 분리하면 된다
	
	- 3차원 방문처리를 하자

### 📌 배운 점
- 상태를 포함한 BFS 설계

	- 동일한 (x, y) 좌표라도 벽을 부쉈는지 여부에 따라 완전히 다른 상태가 되므로, 방문 배열을 visited[N][M][2]처럼 3차원으로 확장해야 함.

	- BFS 큐에는 (x, y, breakUsed) 형태로 상태를 넣어, 한 번만 벽을 부술 수 있는 제약을 자연스럽게 표현했다.

- 단순 가중치 1 그래프에서는 BFS가 최단거리

	- 가중치가 모두 1이므로 다익스트라 대신 BFS로도 최단 거리를 얻을 수 있다는 점을 다시 확인했다.

	- “벽을 부수지 않은 상태”와 “부순 상태” 두 레이어를 동시에 탐색하더라도, 한 번의 BFS로 충분하다.