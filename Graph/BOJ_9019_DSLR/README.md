# 1. 이해

```
[명령어]
- D : n을 두 배 -> 만약 9999보다 크면 나머지 뒤에 네 자리 수를 취할 것
- S : n - 1 -> 0이면 9999로 바꿀 것
- L : 왼쪽으로 숫자 shift하고 첫 번째꺼를 마지막으로 옮기기(Ring)
- R : 오른쪽으로 숫자 shift하고 마지막 꺼를 첫 번째로 옮기기(Ring)

[출력]
- A에서 B로 변환하기 위해 필요한 최소한의 명령어를 나열하라

[입력]
- T개의 테스트 케이스
- A, B
```

# 2. 설계

```
1. 구현
- 명령어를 구현한다
- 이 부분이 어려워서 이 문제가 골드인듯

2. BFS
- 4가지 명령을 수행하면서 만약 B에 도달하면 종료하도록 완전 탐색을
수행한다
- 걍 Flood Fill임
```

## 💡 BOJ 9019 - DSLR [[문제 링크](https://www.acmicpc.net/problem/9019)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `그래프 탐색`, `Brute-Force` |
| 사용 알고리즘 | `BFS` |
| 난이도 | 골드4 |

### ✅ 문제 설명
- N x M x H 크기의 토마토 보관 창고가 있음음

- 하루가 지나면 익은 토마토가 '인접한' 익지 않은 토마토에 영향을 줘서 익게 됨

- 인접 == 위 아래 상하좌우

- **며칠이 지나야 모든 토마토가 익는지 출력하는 문제**

### 🔍 풀이 접근
- 만약 H가 없는 2차원이라고 생각하면, 익은 토마토를 큐에 다 때려넣고 토마토를 익히면 된다

- 왜냐하면 '인접한' 애들은 다른 lev로 구분해선 안되므로, BFS가 옳다

- 이제 H를 고려해보자

- 그냥 3차원 맵을 만들고, 2차원 하듯이 방향배열에 '위' '아래' 방향 배열을 만들면 될거같다

### 💡 핵심 로직
- dz를 추가해 3차원 배열에서 BFS 탐색한다

### 📌 배운 점
- 3차원 BFS를 학습했습니다.