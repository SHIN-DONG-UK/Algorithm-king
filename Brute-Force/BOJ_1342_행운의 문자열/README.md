## 💡 BOJ 1342 - 행운의 문자열 [[문제 링크](https://www.acmicpc.net/problem/1342)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Brute-Force` |
| 사용 알고리즘 | `같은 것이 있는 순열` |
| 난이도 | `실버1` |

---

### ✅ 문제 설명
**[문제 요약]**

- 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열
- 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열의 개수를 구하라

**[제약 사항]**

- S의 길이 <= 10
- 알파벳은 소문자이다

---

### 🔍 풀이 접근
**[나이브한 생각]**
- 길이가 최대 10이므로, N! 가능하다
- 경우의 수 계산 x 10번의 반복문 = 3천만번 => 시간 내에 수행 가능하다
- 즉, 팩토리얼로 문자열을 재배치하고, 최대 10번의 반복문으로 검사를 진행하는 과정을 수행하면 되지 않을까?

**[이슈]**

- 같은 문자열이 여러 번 등장할 수 있음
- 중복된 건 카운트하면 안됨
- 중복되지 않도록 unordered_set을 사용했지만, 메모리 초과 발생(+시간초과)
- 그냥 중복을 무시하면 되네
- 같은 것이 있는 순열로 만들어버리면 되노
- 이거 개수를 카운트한다음에 뭐 어떻게 했던거 같은데

---

### 💡 핵심 로직
- 문자 등장 횟수를 카운트해서 같은 것이 있는 순열을 모두 구한다.

---

### 📌 배운 점
- 같은 것이 있는 순열을 구하는 로직에 대해 이해했습니다.
