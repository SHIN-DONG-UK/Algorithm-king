## 💡 BOJ 16198 - 에너지 모으기 [[문제 링크](https://www.acmicpc.net/problem/16198)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Brute-Force` |
| 사용 알고리즘 | `재귀(Recursion)` |
| 난이도 | `실버1` |

### ✅ 문제 설명

**[문제 요약]**

- N개의 에너지 구슬이 일렬로 놓여져 있고, 에너지 구슬을 이용해서 에너지를 모으려고 한다.
- i번째 에너지 구슬의 무게는 Wi이고, 에너지를 모으는 방법은 다음과 같으며, 반복해서 사용할 수 있다.
   1. 에너지 구슬 하나를 고른다. 고른 에너지 구슬의 번호를 x라고 한다. 단, 첫 번째와 마지막 에너지 구슬은 고를 수 없다.
   2. x번째 에너지 구슬을 제거한다.
   3. W_x-1 * W_x + 1의 에너지를 모을 수 있다.
   4. N을 1 감소시키고, 에너지 구슬을 1번부터 N번까지로 다시 번호를 매긴다. 번호는 앞에서부터 순서대로 1,2,...

- N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하라

**[제약 사항]**

- 에너지 구슬의 개수 N <= 10
- 에너지 구슬의 무게 W <= 1,000

### 🔍 풀이 접근
- 문제의 크기(구슬의 개수)가 최대 10이라 그냥 Brute-Force하면 된다
- N! 혹은 2^N이 가능하다
- Brute-Force하게 모든 경로를 계산한 다음 최댓값을 갱신하는 방식으로 문제를 해결하면 되겠다
- 그냥 팩토리얼하면 되겠다
- 그런데, 양 끝 구슬은 선택할 수 없으며 양쪽 구슬이 계속 업데이트되므로 이걸 구현해줘야 한다

### 💡 핵심 로직
- 양 쪽 구슬을 곱하는 구현을 어떻게 처리할까?
- 왜냐하면 실제로 구슬을 삭제하는게 아니라 논리적으로 삭제하기 때문에, 이걸 구현하려면 논리적으로 삭제한 부분을 건너뛰고 계산해야 한다
- 사실 그냥 건너뛴다는 것으로 해결이 가능하다
- 왼쪽으로 처음으로 삭제되지 않은 구슬을 선택하고, 마찬가지로 오른쪽으로 처음으로 삭제되지 않은 구슬을 선택하는 식으로 하면 된다

### 📌 배운 점
- 모든 경우를 고려해서 최적해를 구할 수 있음을 이해하고, 구현사항을 만족시켜 정답을 도출하는 연습을 했습니다.