## 💡 BOJ 1436 - 영화감독 숌 [[문제 링크](https://www.acmicpc.net/problem/1436)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Brute-Force` |
| 사용 알고리즘 | `while-loop` |
| 난이도 | `실버5` |

### ✅ 문제 설명
- `종말의 수` : 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수

- 제일 작은 종말의 수 = 666

- N번째 종말의 수를 구하라

### 🔍 풀이 접근
- 숫자를 나열해본다.
    ```
    0666 1666 2666 3666 3666 5666 [6660~6669] 7666 8666 9666 => 9+10
    10666 11666 12666 13666 14666 15666 [16660~16669] 17666 18666 19666 => 9+10
    20666 21666 22666 23666 24666 25666 [26660~26669] 27666 28666 29666 => 9+10
    30666 31666 32666 33666 34666 35666 [36660~36669] 37666 38666 39666 => 9+10
    40666 41666 42666 43666 44666 45666 [46660~46669] 47666 48666 49666 => 9+10
    50... => 9+10
    60666 61666 62666 63666 64666 65666 [66600~66699] 67666 68666 69666 => 9+100
    ```

- 666을 뼈대로 쓰자

- 숫자 하나를 1씩 늘려가면서 666에 붙이자
    - `0`666 > `1`666 > `2`666 > `3`666 .. `55`666

- 이걸 카운팅 변수라고 하면, 카운팅 변수에 카운팅 변수*1000을 더한다

- 카운팅 변수가 1의 자리부터 6이 몇 개 연속하는지 센다

- 만약 존재한다면, 그 개수만큼 원래 숫자의 1의 자리부터 6을 뺀다

- 그리고 1씩 증가시킨다

- 이제 순서를 기록하면서 순서가 될 때 반복문을 탈출한다


### 💡 핵심 로직
```cpp
void simulation(){
    int cnt = 0;
    int ord = 0;
    int add, k, six;
    
    while(true){
        add = cnt * 1000;
        k = how(cnt);
        ans = 666 + add;
        
        if(k == 0){
            ord++;
            if(ord == N) return;
        }
        else{
            six = sub(ans, k);
            ans -= six+1;
            
            for(int i=0; i<pow(10, k); i++){
                ans++;
                ord++;
                if(ord == N) return;
            }
        }
        cnt++;
    }
}
```

### 📌 배운 점
- `Brute-Force`하게 원하는 숫자를 만드는 구현력을 길렀습니다.