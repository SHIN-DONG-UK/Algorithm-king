## 💡 BOJ 15954 - 인형들 [[문제 링크](https://www.acmicpc.net/problem/15954)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Brute-Force` |
| 사용 알고리즘 | `누적합`, `Brute-Force` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- N개의 인형이 있고, 잘 팔리는 인형은 상대적으로 사람들이 많이 볼 수 있는 곳에 배치하고, 잘 안팔리는 인형은 상대적으로 사람들이 적게 볼 수 있는 곳에 배치한다
- 인형 배치 방법
  - 먼저 비슷한 인형이 가깝게 위치하도록 서로 다른 N개의 인형을 종류당 한 개씩 일렬로 배치
  - 그 후, 선호하는 사람의 수의 표준편차가 최소가 되는, K개 이상의 연속된 위치에 있는 인형들을 선택하여 그들을 같은 곳에 배치

- 위의 방법으로 인형들을 선택했을 때, 선택된 인형들의 선호하는 사람의 수의 표준편차를 구하라

**[제약 사항]**

- 인형의 개수 N : 1 <= N <= 500
- 표준편차가 최소가 되도록하는 K : 1 <= K <= N

### 🔍 풀이 접근
- 일단 문제에서 인형 배치 방법의 1단계는 이미 되어 있다고 생각하면 되는듯?
- 2단계만 우리가 신경쓰면 되겠다
- Brute-Force하게 찾으면 안되나?
- 시간복잡도를 한 번 계산해보자
- K=1이라고 하자
- N=500이라고 하자
- 길이가 1인 경우부터 쭉 해본다
- 길이가 2 -> ... -> 길이가 500
- 시간복잡도는 O(N^2)이다
- 근데 각 케이스마다 평균을 구하고, 분산을 구하는 연산이 반복된다
- 평균은 O(1)만에 구할 수 있다 -> 누적합 배열이 있으면 된다
- 분산도 O(1)만에 구할 수 있다 -> 누적합 배열이 있으면 된다
- 결국 O(N^2)만에 문제 해결 가능하다
- O(N^3)이면 시간초과

### 💡 핵심 로직
- 단순 누적합 배열을 구한다
- 분산 누적합 배열을 구한다
- 길이가 K인 경우부터 N인 경우까지 쭉 Brute-Force로 최솟값을 update한다
- sqrt로 정답을 구한다

### 📌 배운 점
- long double이 높은 정밀도를 갖는 자료형임을 알게 되었습니다.
- sqrt 시 정밀도가 손실될 수 있음을 이해했습니다.
- 누적합 배열을 통해 시간복잡도를 최적화했습니다.