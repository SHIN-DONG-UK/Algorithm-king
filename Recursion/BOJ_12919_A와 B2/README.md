## 💡 BOJ 12919 - A와 B 2 [[문제 링크]](https://www.acmicpc.net/problem/12919)

| **항목** | **내용** |
| - | - |
| **문제 유형** | `재귀` |
| **사용 알고리즘** | |
| **난이도** | `골드5` |

### ✅ **문제 설명**`
**[문제 요약]**

- 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임을 할거다
- 문자열을 바꿀 때는 다음 두 가지 연산만 가능하다
   - 문자열 뒤에 A를 추가한다
   - 문자열 뒤에 B를 추가하고 문자열을 뒤집는다
- 주어진 조건을 이용해서 S를 T로 만들 수 있는지 알아내라

**[제약 사항]**

- 1 <= S의 길이 <= 49
- 2 <= T의 길이 <= 50
- S < T

### 🔍 **풀이 접근**
- 'A와 B' 문제처럼 그리디하게 안된다
- DFS로 구현하자
- 실제로 문자열을 뒤집고 원복하는 건 DFS 구현이 어렵다
- 구간과 방향 파라미터만 넘겨주는 방식을 쓸 수 있다

### 💡 **핵심 로직**
- 만약 현재 '구간'이 S의 길이와 같다 -> 검사

- 만약 현재 '구간'이
A...A 이다 -> 맨 뒤에거 삭제하고 go
A...B 이다 -> 리턴
B...A 이다 -> 둘 다 해본다 go
B...B 이다 -> 맨 앞에거 삭제하고 뒤집고 go

### 📌 배운 점
- 반례로부터 문제 풀이 방향성을 찾아냈습니다.
- 문자열에서 재귀 탐색할 때, 전체를 뒤집는 연산과 삭제하는 연산이 있는 경우 모든 문자열을 다 파라미터로 넘기지 않고 구간과 방향으로 문자열을 탐색할 수 있음을 알게 되었습니다.