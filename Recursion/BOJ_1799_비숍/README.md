## 💡 BOJ 1799 - 비숍 [[문제 링크]](https://www.acmicpc.net/problem/1799)

| **항목** | **내용** |
| - | - |
| **문제 유형** | `재귀` |
| **사용 알고리즘** | `백트래킹` |
| **난이도** | 플레티넘5 |

### ✅ **문제 설명**
- **비숍을 둘 수 없는 칸이 존재하는 맵에서, 비숍을 서로 겹치지 않게 둘 수 있는 최대 개수를 구하는 문제**

### 🔍 **풀이 접근**
처음에는 **그리디**로 접근했으나, 오답처리를 받고 그냥 **Brute-Force**해야 겠구나 생각했다. 어떤 칸에 비숍을 두거나, 두지 않거나 이 두가지를 모든 칸에 대해 수행해보면, 최악의 경우 $2^{100}$번을 수행해야 한다. (N=10이고 모든 칸이 1인 경우)

실제로 $2^{100}$번을 연산하지는 않겠지만, 그래도 시간초과가 발생할 것은 분명하다. 그런데 **체스판에서 흰색 칸의 비숍과 검은색 칸의 비숍은 절대 겹치지 않는다.** 그래서 흰색 칸에서의 Brute-Force와 검은색 칸에서의 Brute-Force를 따로 구한 다음 더해도 해는 같다. 이렇게 하면 $2^{100}$의 연산을 $2^{50}$수준으로 줄일 수 있다. 즉, **1,000,000,000,000,000배** 빠르게 연산할 수 있다는 뜻이다.

### 💡 **핵심 로직**
**재귀 함수**

1. 종료 조건    
    - 깊이가 size()까지 갔으면 종료

2. 가지치기
    - 앞으로 다 놓는다고 해도 최고 못넘으면 컷
    - 대각선 컷

3. 함수 메인
    - 현재 칸에 비숍을 놓기
    - 놓지 않기

### 📌 배운 점
- 문제에서 비숍의 속성을 이용해 알고리즘 수행 시간을 줄이는 인사이트를 발견해내는 문제라는 것을 느꼈습니다. 문제에서 대상의 속성으로부터 인사이트를 발굴해서 알고리즘 시간을 줄일 수 있구나 이런 문제도 있구나 느꼈습니다.