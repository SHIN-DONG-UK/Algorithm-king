## 💡 BOJ 9663 - N-Queen [[문제 링크]](https://www.acmicpc.net/problem/9663)

| **항목** | **내용** |
| - | - |
| **문제 유형** | `재귀` |
| **사용 알고리즘** | `백트레킹` |
| **난이도** | 골드4 |

### ✅ **문제 설명**`
- **N x N 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제**

### 🔍 **풀이 접근**
퀸을 어느 한 지점에 두었을 때, 그 지점으로부터 가능한 모든 퀸의 배치를 탐색하면 문제를 해결할 수 있다. 그런데 어떤 칸에 퀸을 놓았을 때, 다음 퀸이 놓을 수 있는 범위가 변한다. 따라서 재귀적으로 탐색해서 문제를 해결해보자.

아래와 같이 더 이상 탐색할 필요가 없는 노드가 있다.

- `i`행에 퀸을 놓은 다음, 다른 퀸은 **`i` 행**에 둘 수 없다 

- `j`행에 퀸을 놓은 다음, 다른 퀸은 **`j` 열**에 둘 수 없다

- `(i, j)`위치에 퀸을 놓은 다음, 다른 퀸은 **같은 대각선**에 둘 수 없다
  -> 같은 대각선인걸 어떻게 알까?
  - `\` 방향 대각선은 `|행 - 열|`의 값이 같다
  - `/` 방향 대각선은 `행 + 열`의 값이 같다
  
위 노드들을 건너뛰고, 재귀적으로 가능한 퀸의 배치를 구하면 짧은 시간복잡도에 정답을 구할 수 있을 것이다.

### 💡 **핵심 로직**
재귀 함수에서 다음 깊이로 들어가는 것(`lev+1`)을 다음 열로 이동하는 거라고 생각해보자. 어차피 같은 열에는 퀸을 둘 수 없으므로, 재귀 함수를 이렇게 구성하면 반복문을 하나 줄일 수 있다.

또한 중복해서 퀸 배치의 개수를 세는 경우를 생각하지 않아도 된다.

### 📌 배운 점
재귀 함수의 깊이 들어가는 매커니즘을 열의 이동으로 활용해 중복 카운트를 제거하고 문제 요구사항을 충족할 수 있음을 깨달았습니다.