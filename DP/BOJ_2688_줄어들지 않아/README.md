## 💡 BOJ 2688 - 줄어들지 않아 [[문제 링크](https://www.acmicpc.net/problem/2688)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- 어떤 숫자가 줄어들지 않는다는 것은 그 숫자의 각 자리 수보다 그 왼쪽 자리 수가 작거나 같을 때
- 숫자의 앞에 0이 있어도 된다
- n이 주어졌을 때, 줄어들지 않는 n자리 수의 개수를 구하라

**[제약 사항]**

- 테스트 케이스 개수 T <= 1,000
- 1 <= n <= 64

### 🔍 풀이 접근
- n=2를 해보자
   - 0 10개
   - 1 9개
   - 2 8개
   - 9 1개
   => 10 + 9 + 8 + ... + 1 = 55

- n = 3을 해보자
   - 0 0 10개
   - 0 1 9개
   - ...
   - 0 9 1개 
   => 10 + ... + 1 = 55
   - 1 1 9개
   - 1 2 8개
   - ...
   - 1 9 1개
   => 9 + ... + 1 = 45
   - 2 2 8개
   ...
   => 8 + ... + 1 = 36
   ...
  => 1

  - S(1) + S(2) + S(3) + ... + S(10) = 1 + 3 + 6 + 10 + 15 + 21 + 28 + 36 + 45 + 55 = 

- 규칙이 보인다
- n=2일 때는 S(10)
- n=3일 때는 T(10)
- n=4일 때는 Q(10)이겠죠
- 그니까 n=2에서 구한 값으로 n=3의 값을 구하고, 또 n=4의 값을 구하는 식으로 누적해 나가야 한다

Sarr -> 1 2 3 4 5 6 7 8 9 10
Tarr -> n(n+1)/2로 구할 수 있음
Qarr -> Tarr를 누적해서 구할 수 있음
Larr -> Qarr를 누적해서 구할 수 있음...

미리 64개를 구해놓으면 된다!

### 💡 핵심 로직
```
n=1 0 1 2 3 4 5 6 7 8 9 10
n=2 0 1 3 6 10 15 21 28 36 45 55
n=3 0 1 4 10 20 35 56 84 120 165 220
n=4 0 1 5 15 35 70 126 210 330 495 715
...
n=64 0...
```

### 📌 배운 점
- 문제 상황을 이해하고 누적결과를 활용해야 함을 이해하고 DP로 해결했습니다.