# 1. 이해

```
[상황]
- 계단이 있음
- 각 계단에는 점수가 있음
- 밟으면 점수 획득

[계단 오르기 규칙]
1. 한 번에 한 개 혹은 두 개씩 오를 수 있음
2. 연속된 세 개 밟으면 안됨(단, 시작점은 개수 안침)
3. 마지막 도착 계단은 반드시 밟아야 함

[출력]
- 주어진 규칙에 따라 획득할 수 있는 점수의 최댓값을 출력하라

[입력]
- 계단의 개수 N (1≤N≤300)
- 점수... (1만 이하 자연수)
```

# 2. 설계

```
1. OOXOOXOOXOO...로 하면 안되냐?
	-> 1 1 10000 1 1 10000 1 1 20000 1 1... 이런 케이스는 못하잖아
2. 모든 경우의 수를 따져보면 안되나?
	-> N은 최대 300이잖아 -> 2^300 -> 말도 안돼
3. 흠... 마지막 계단은 무조건 밟아야 하니까, 뒤에서부터 한 번 생각해보는게 어때
	-> 한 칸 앞 vs 두 칸 앞
	-> 이제 첫 번째 인덱스에 기록된 점수가 있음
	-> 이 문제에서는 경로는 필요없을듯
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f0d09fab-f760-445a-969a-74459f3b88cd/bc901cc3-0a54-4678-8818-4f633d619e70/image.png)

# 3. 설계 오류

### 반례

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f0d09fab-f760-445a-969a-74459f3b88cd/765b3d53-7b58-4c4c-8dc4-0f7b4db88903/image.png)

### 어떻게 풀어야 할까?

```
1. dp[i]에는 i까지의 최적해가 구해져 있다
2. 여기에 값을 더하기만 하면 된다
3. 그럼 어떻게 더하냐? -> max(한 칸 띄우고 계산, 두 칸 띄우고 계산)
이게 다임
```