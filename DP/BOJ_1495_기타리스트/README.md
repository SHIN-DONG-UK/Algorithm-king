## 💡 BOJ 1890 - 점프 [[문제 링크](https://www.acmicpc.net/problem/1890)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | `DP` | 
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- N개의 곡이 있다
- 매번 곡이 시작하기 전에 볼륨을 바꾸고 연주하려고 한다
- 각각의 곡이 시작하기 전에 바꿀 수 있는 볼륨 리스트 V가 있다
- V[i] : i번째 곡을 연주하기 전에 바꿀 수 있는 볼륨
- 현재 볼륨이 P이고 i번째 곡이라고 할 떄, i번 곡은 P + V[i] or P - V[i]로 연주해야 한다
- 단, 0보다 작은 볼륨이나 M보다 큰 볼륨으로 바꿀 수 없다
- 곡의 개수 N과 시작 볼륨 S, 그리고 M이 주어졌을 때, 마지막 곡을 연주할 수 있는 볼륨 중 최댓값을 구하라

**[제약 사항]**

- 곡의 개수 N <= 50
- 볼륨 제한 M <= 1,000
- 시작 볼륨 S <= M
- 마지막 곡을 연주할 수 없다면 -1을 출력(중간에 볼륨을 조절할 수 없는)

### 🔍 풀이 접근
- 마지막 곡 까지 갔을 때 볼륨이 최댓값이 되도록 볼륨을 늘리고 줄여야 한다
- 그 와중에 M보다 커지면 안되고, 0보다 작아지면 안된다
- 첫 번째 예제
3 5 10
5 3 7
일 때 -5 +3 +7하면 마지막에 10이고 이게 최대임

- 두 번째 예제
4 8 20
15를 줄이면 0보다 작아지고, 15를 더하면 M(=20)보다 커져서 볼륨을 조절할 수 없음 -> -1

- Brute-Force하게 접근하면 어떻게 될까?
    - 그니까 i번째 곡마다 뺴거나 더하는 모든 경우를 생각해보는거임
      - 이 경우 시간복잡도는 2^50 -> 10^15 -> 시간초과

- DP를 활용할 수 있나? bottom-up으로 최적해를 누적해서 구할 수 있을까? 혹은 작은 문제를 일관되게 풀어서 큰 문제를 해결할 수 있나?
    - 일관되게 푸는게 힘들어보인다
    - 항상 최댓값 혹은 최솟값을 유지하고 있어야 하는데, 이 문제에 적합하지는 않음

- 아니면 Brute-Force에서 가지치기를 잘하면 시간이 괜찮지 않을까?
    - 가다가 안되면 바로 리턴때리면 좀 줄지 않을까

### 💡 핵심 로직
- Brute-Force는 시간초과남
- 무줴건 memoization을 사용해야하는듯?
- 각 단계마다 가능한 볼륨들을 다 저장하고 있음
- 가능한 볼륨들을 쫙 돌면서 다음 단계로 전이
- 이렇게 전이하면 마지막 곡에서 많은 게 true로 될거임
- 여기서 가장 큰 거 그냥 리턴때리면 됨
- 어떻게보면 탐색인데 방문처리로 중복을 제거하는 느낌?

### 📌 배운 점
- memo를 하는데 방문처리로 중복을 제거하는 느낌의 dp 문제를 풀이했습니다.