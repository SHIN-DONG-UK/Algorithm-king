## 💡 BOJ 11660 - 구간합 구하기5 [[문제 링크](https://www.acmicpc.net/problem/11660)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | 누적합 |
| 사용 알고리즘 | DP |
| 난이도 | 실버1 |

### ✅ 문제 설명
**[상황]**
- N x N개의 수가 N x N의 표에 존재

**[출력]**
- (x1, y1)부터 (x2, y2)까지의 합을 구하라

**[입력]**
- 표의 크기 N, 합을 구하는 횟수 M (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100000)
- 맵 정보
- 좌표들 (x1 ≤ x2, y1 ≤ y2)

### 🔍 풀이 접근

#### 일단 적어보자
**[생각]**
- 합을 구하는 횟수가 최대 10만, 합의 개수 최대 1024 x 1024 = 1백만
- 무조건 시간초과

**[시간을 줄이는 방법]**
- 합이 구해져 있는 테이블을 만들 것
- 여기서 O(1)만에 접근해서 계산 가능하도록 할 것

**[테이블]**
- (1, 1) -> (x2, y2) 합을 미리 구해놓자
- 예시
```
	1 2 3 4
	2 3 4 5
	3 4 5 6
	4 5 6 7
	이라고 하면,
	1 3 6 10
	3 8 15 24
	6 15 27 42
	10 24 42 64
	
	이제 (2,2) -> (3,4)를 구해보자
	위 테이블에 따르면, table[3][4] - table[1][4] - table[3][1]임
	
	(2,1) -> (3,2)를 구해보자
	위 테이블에 따르면, table[3][2] - table[1][2] - table[3][0]임
	
	규칙이 보이쥬?
	value = table[x2][y2] - table[x1-1][y2] - table[x2][y1-1]
```

#### 누적합
- 누적합을 미리 구해놓고, O(1)으로 접근해 단순 사칙연산으로 최적해를 구하자.

- 누적합을 build할 때에도 시간초과 방지를 수행하자.

### 💡 핵심 로직
```cpp
for(int i=1; i<=N; i++){
        for(int j=1; j<=N; j++){
            table[i][j] = table[i-1][j] + table[i][j-1] + MAP[i][j] - table[i-1][j-1];
        }
    }
```
- 누적합을 build할 때에도 로직 적용.

### 📌 배운 점
- 누적합을 이용해 O(1)으로 최적해를 구하는 최적화 기법을 이해했습니다.

- 누적합을 build할 때에도 최적화 기법을 적용해야 함을 인식했습니다.
