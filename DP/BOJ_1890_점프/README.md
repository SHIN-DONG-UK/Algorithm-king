## 💡 BOJ 1890 - 점프 [[문제 링크](https://www.acmicpc.net/problem/1890)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | `DP` | 
| 난이도 | 실버1 |

### ✅ 문제 설명
**[문제 요약]**
- N x N 게임판에 수가 적혀 있음
- 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프해서 가는 것
- 각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리
- 반드시 오른쪽 혹은 아래쪽으로만 이동해야 함
- 0은 더 이상 진행을 막는 종착점
- 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 문제

**[제약 사항]**
- 게임 판의 크기 4 <= N <= 100
- 칸에 적혀있는 수는 0 ~ 9
- 경로의 개수는 2^63-1보다 작거나 같음

### 🔍 풀이 접근
- BFS로 풀면 되지 않나?
- 그런데, BFS로 풀이하면 메모리 초과가 발생한다
- 중복을 허용해야 하므로, queue에 너무 많은 Node가 입력되기 때문
- 경로를 진행하지 말고 정답을 구할 수 있어야 한다
    - 즉, BFS 혹은 DFS로 풀이 할 수 없다
- 가능한 칸에 "누적"하는 방식으로 풀 수 있지 않을까?
    - 모든 칸 방문 후 알고리즘은 종료됨
    - 시간복잡도 : $O(N^2)$ 수준

### 💡 핵심 로직
- 모든 칸을 돌면서 이 칸에 도달할 수 있는 "위쪽" 칸들과 "왼쪽" 칸들에 경로 개수를 "누적"한다

### 📌 배운 점
- 모든 경로를 진행하지 않고 정답을 구하기 위해 DP를 떠올리고 문제에 적용했습니다.