## 💡 BOJ 11057 - 오르막수 [[문제 링크](https://www.acmicpc.net/problem/11057)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | Bottom-up DP, 누적합 |
| 사용 알고리즘 | DP |
| 난이도 | 실버1 |

### ✅ 문제 설명

- 오르막 수는 수의 자리가 오름차순을 이루는 수

- 2234, 3678, 11119는 오르막 수

- 2232, 3676, 91111은 오르막 수가 아님

- 0으로 시작 가능

- 수의 길이 `N`이 주어질 때, 오르막 수의 개수를 구하라

### 🔍 풀이 접근

#### 일단 적어보자
```
(1자리)
0
1
2
3
4
5
6
7
8
9

(2자리)
00 01 02 03 04 05 06 07 08 09 => 10
11 12 13 14 15 16 17 18 19 => 9
22 23 24 25 26 27 28 29
33 34 35 36 37 38 39
44 45 46 47 48 49
55 56 57 58 59
66 67 68 69
77 78 79
88 89
99 => 1

(3자리)
000 001 002 .. 009
011 012 .. 019
022 .. 029
033 .. 039
..
099
=>55

111 112 113 .. 119
122 123 .. 129
133 134 .. 139
144.. 149
..
199
=>45

...
Sn = 1 + 2 + 3 + ... + n

1자리
10

2자리
S10 = 1+2+3+...+10 = 55

3자리
S10 + S9 + S8 + ... S1 = 220
```

#### 누적합
- N자리 오르막수의 개수를 구하기 위해, 1자리 오르막수부터 누적함을 쌓아가면 구할 수 있겠다.

- 세 자리 오르막수를 구할 때 S10 + S9 + S8 +...+ S1이다.

- 누적합 배열 S를 선언하고 S[10]에 N자리 오르막수가 저장된다.

### 💡 핵심 로직
```cpp
void sum(){
    int rst = 0;
    
    for(int i=1; i<=10; i++){
        rst += S[i];
        S[i] = rst % 10007;
    }
}
```

### 📌 배운 점
- DP의 한 축인 누적합으로 최적해를 구할 수 있음을 이해했습니다.
