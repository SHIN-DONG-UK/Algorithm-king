## 💡 BOJ 2011 - 암호코드 [[문제 링크](https://www.acmicpc.net/problem/2011)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | | 
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- 상근이와 선영이가 대화를 암호화 하기로 함
- A=1, B=2, ..., Z=26으로
- 어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지 나올 수 있는지 구하라

**[제약 사항]**

- 암호는 숫자로 이루어져 있다
- 암호는 5000자리 이하이다
- 나올 수 있는 해석의 가짓수가 매우 클 수 있으므로, 1,000,000으로 나눈 나머지를 출력한다
- 암호가 잘못되어 해석할 수 없는 경우 0을 출력

### 🔍 풀이 접근
- 알파벳은 길이 1 혹은 2로 표현된다
- 암호를 1개 혹은 2개씩 끊어서 변환한다
- 이 문제는 이전에 구한 개수를 기반으로 현재 개수를 구할 수 있다

- 예를 들어, 25114에서 251까지의 개수를 안다고 하자
1 2 2이다
이제 2511을 검사할거다
뒤에 1이 추가됨으로써 두 가지 경우가 생긴다
길이1 -> 251에서 구한 경우를 그대로 가질 수 있음
길이2 -> 25에서 구한 경우를 그대로 가질 수 있음
그래서 2511의 개수는 2 + 2 = 4임

- 마지막으로 2511에 4를 추가해보자
길이1 -> 2511의 개수를 그대로 가질 수 있다
길이2 -> 251의 개수를 그대로 가질 수 있다
그래서 25114의 개수는 4 + 2 = 6임

### 💡 핵심 로직
- 예외 -> 0인 경우는 어떻게 처리하지?
- 0은 혼자올 수 없다
- 0은 무조건 앞에 1 또는 2여야 한다
- 0은 맨 앞에 올 수 없다

1. opt[1]을 구한다.
- 만약 첫 번째 암호가 0이면 그냥 안되니까 종료
- 그렇지 않으면 opt[1] = 1

2. 누적해 나간다.
- 만약 현재 암호가 0이면, 앞을 봐야 함
   - 앞이 1또는2면 opt[i-2]만 더함
   - 그리고 이 다음 애는 항상 1만 됨
- 그렇지 않으면, opt[i] = opt[i-1] + opt[i-2]
   - 만약 앞이랑 현재가 26보다 크면 opt[i-2]는 할 수 없음

### 📌 배운 점
- 누적해서 최적해를 구할 수 있음을 이해했고, 각 스테이지에서 예외처리를 하는 연습을 했습니다.