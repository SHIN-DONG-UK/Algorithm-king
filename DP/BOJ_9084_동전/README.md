## 💡 BOJ 9084 - 동전 [[문제 링크](https://www.acmicpc.net/problem/9084)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | |
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- 우리나라 화폐단위 중 동전에는 1, 5, 10, 50, 100, 500원이 있다
- 이 동전들로 정수의 금액을 만들 수 있으며 그 방법은 여러가지
- 예를 들어, 30원을 만들기 위해서는 1원짜리 30개 또는 10원짜리 2개와 5원짜리 2개 등
- 동전의 종류가 주어질 때 주어진 금액을 만드는 모든 방법을 구하라

**[제약 사항]**

- 테스트 케이스 T가 주어짐 1 <= T <= 10
- 각 테스트 케이스에는 동전의 가지 수 N이 주어짐 1 <= N <= 20
- 각 동전은 정수이며 1에서 10,000원까지 있을 수 있다
- N가지 동전으로 만들어야 할 금액 M이 주어진다 1 <= M <= 10,000
- 같은 동전이 여러 번 주어지는 경우는 없다

### 🔍 풀이 접근

- M원을 만드는 경우의 수를 만들기 위해, sub원을 만드는 경우를 합치면 되지 않나?
- 즉, DP적으로 문제를 해결할 수 있을것 같다
- M원을 만드는데 동전이 { 1, 5, 10 } 있다고 하자
- f(M) = f(M-1) + f(M-5) + f(M-10)을 하면 되지 않을까?
- 그런데, 각 f에는 중복한 경우가 존재한다
- 이걸 걸러야 함

### 💡 핵심 로직

- dp[s]만 있으면 "어떤 방식으로 만들어졌는지" 정보가 없어서 중복
- 그래서 차원을 하나 늘려서 s원을 만드는 방법을 제한
- dp[s][i] = dp[s][i-1] + dp[s - coin[i]][i]
- dp[s][i] = i번째 coin까지 써서 s원을 만드는 경우의 수
- dp[s][i-1] = i-1번째 coin까지 써서 s원을 만드는 경우의 수
- dp[s - coin[i]][i] = i번째 coin까지 서서 s - coin[i]원을 만드는 경우의 수

### 📌 배운 점
- 1차원 dp로 문제를 접근했을 때 불가능한 이유에 대해 고민할 수 있었습니다.
- 2차원으로 확장했을 때 "특정 금액을 만드는 방법을 제한한다"는 의미를 가진다는 것을 이해했습니다.