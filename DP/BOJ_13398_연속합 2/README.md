## 💡 BOJ 13398 - 연속합 2 [[문제 링크](https://www.acmicpc.net/problem/13398)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `DP` |
| 사용 알고리즘 | |
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- n개의 정수로 이루어진 임의의 수열이 주어진다
- 이 중 몇 개의 연속된 수를 선택해서 구할 수 있는 합 중 가장 큰 값을 구하려고 함
- 단, 수는 한 개 이상 선택해야 함
- 또, 수열에서 수를 하나 제거할 수 있음

**[제약 사항]**

- n <= 100,000
- -1,000 <= 수 <= 1,000

### 🔍 풀이 접근
- 먼저 수 하나를 제거하지 않는 경우를 생각해보자
- a에서 b까지의 연속합은 누적합 배열을 만들어놓으면 된다
- S[k]를 0부터 k인덱스까지의 합이라고 하자
- 인덱스 a에서 b까지의 합은 S[b] - S[a-1]로 정의된다
- 즉, a에서 b까지의 합은 S[k] ( k=0~n-1 )가 정의되어 있다는 가정하에, O(1) complexity가 가능하다
- 여기서 S[b] - S[a-1]의 최댓값을 구하는걸 생각해보자
- A가 음수가 아니면 단조성이 보장되기 때문에 투 포인터로 문제를 해결할 수 있다
- 근데 문제는 A가 음수일 수 있다
- 그래서 DP를 쓰는게 맞다

### 💡 핵심 로직

- 그리디하게 최적 삭제 지점을 결정하는건 어떨까?
- 그러니까, 가장 작은 값을 삭제하는것
- 그런데 값만 보고 최적 삭제 지점을 보장하지 못함
- 10 -1 10 -100 10
- 여기서 -100을 삭제하면 19인데, -1을 삭제하면 20임
- 그래서 그리디하게 삭제 지점을 결정할 수 없음
- 결국 동적으로 삭제 지점이 결정되기 때문에, 이를 고려한 DP가 필요함
- A[i]를 삭제한 경우와 그렇지 않은 경우 두 개를 갖고 있으면 대응이 된다
- 현재 값을 삭제한 것의 최적과 현재 값을 삭제하지 않은 것의 최적을 들고 있어서, 둘 중 더 큰 값을 정답으로 내면 된다
- 이를 점화적으로 수행하면 최적해를 구할 수 있다

### 📌 배운 점
- 투포인터가 작동하는 상황은 수열이 단조성을 가지며, 길이 제한이 있는 상황에 유효함을 이해했습니다.
- 그리디하게 접근하면 안되는 반례를 이해했고, 이를 해결하기 위해 두 개의 DP를 들고 있도록 하는 방법을 이해했습니다.
