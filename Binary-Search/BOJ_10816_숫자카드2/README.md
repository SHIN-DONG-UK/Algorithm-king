# 1. 이해

```
- 숫자 카드 N개 (1 <= N <= 500,000)
- 정수 M개 ( 1 <= M <= 500,000)

[출력]
상근이가 정수를 몇 개 갖고 있는지 출력하라
```

# 2. 설계

```
- 앞에서 부터 찾아가는게 맞나?
- 최악의 경우, 500,000 x 500,000 => 2천5백억 -> 말도 안됨
- 그래서 Binary Search해야 함
- Binary Search하기 위해 N이 정렬되어 있어야 겠구나!
- 해당 target을 찾고, target을 왼쪽과 오른쪽으로 탐색하면서 개수를 찾으면 되지 않을까?
- 중복된 숫자는 미리 배열을 만들어서 개수를 카운트 해 두자
	-> 만약 정렬된 숫자 배열에서 다른 숫자가 나올 때까지 while문을 돌면서 개수를 카운트하면
		찾아야 하는 숫자가 중복되는 케이스는 시간초과 발생
```

## 💡 BOJ 10816 - 숫자카드2 [[문제 링크](https://www.acmicpc.net/problem/10816)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `파라메트릭 서치` |
| 사용 알고리즘 | `이분 탐색` |
| 난이도 | 실버4 |

### ✅ 문제 설명
- **숫자 카드 `N`개와 정수 `M`개가 주어졌을 때, 정수가 숫자 카드에 존재하는지 출력하라**

### 🔍 풀이 접근
- `N`개의 카드를 정렬하고, 인덱스를 이분 탐색한다

### 💡 핵심 로직
- 이분 탐색으로 값이 존재하면 1을 출력하고, 이분 탐색 함수가 `target`을 찾지 못하고 `false`를 반환하면 0을 출력
	
### 📌 배운 점
- 이분 탐색 기본 문제를 학습했습니다.