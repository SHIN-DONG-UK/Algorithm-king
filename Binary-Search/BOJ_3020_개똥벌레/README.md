## 💡 BOJ 3020 - 개똥벌레 [[문제 링크](https://www.acmicpc.net/problem/3020)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `Binary-Search` |
| 사용 알고리즘 | `lower_bound` |
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- 개똥벌레 한 마리가 장애물로 가득찬 동굴에 들어갔다
- 동굴의 길이는 N미터이고, 높이는 H미터이다.
- N은 짝수
- 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.
- 개똥벌레는 장애물을 피하지 않는다 -> 직선 구간을 정하고 만나는 모든 장애물 파괴
- 동굴의 크기와 높이, 모든 장애물의 크기가 주어질 때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하라

**[제약 사항]**

- 2 <= N <= 200,000
- 2 <= H <= 500,000

### 🔍 풀이 접근
- 먼저 최솟값을 찾는다
- sequential하게 찾으면 TLE다
- 어떤 높이 h에서, 석순은 길이 >= h인 것만 충돌한다
- 종유석은 길이 >= H - h + 1인 것만 충돌한다

### 💡 핵심 로직
- 만약 석순과 종유석 각각이 길이 오름차순으로 정렬되어 있다고 하자
- 석순은 lower_bound(h), 종유석은 lower_bound(H - h + 1)을 찾는다.
- 그 뒤로는 쭉 충돌하므로 충돌 개수를 파악할 수 있다.
- 이제 h를 2부터 H까지 Brute-Force하게 검사하면서, 충돌 개수에 해당하는 인덱스 혹은 unordered_map에 카운팅한다
- 처음으로 값이 0이 아닌 인덱스(==충돌횟수)와 그 값을 출력한다
	
### 📌 배운 점
- 특정 길이만 넘으면, 그 뒤의 개수는 O(1)만에 계산할 수 있다는 것을 깨달았습니다.
- 문제 상황을 두 개의 갈레로 나누는 것을 깨달았습니다.
- lower_bound의 예외 상황을 이해했습니다.