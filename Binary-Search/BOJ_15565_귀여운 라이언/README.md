## 💡 BOJ 15565 - 귀여운 라이언 [[문제 링크](https://www.acmicpc.net/problem/15565)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `이분 탐색` |
| 사용 알고리즘 | `파라메트릭 서치` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- 라이언 인형(1)과 어피치 인형(2)이 N개 일렬로 놓여 있다
- 라이언 인형이 K개 이상 있는 가장 작은 연속된 인형들의 집합의 크기를 구하라

**[제약 사항]**

- K <= N <= 1,000,000
- K개 이상인 집합이 없다면, -1을 출력한다

### 🔍 풀이 접근
**[나이브한 생각]**

- 가장 떠올리기 쉬운 방법이 O(N^2)이다
- 첫 번째 인덱스를 기준으로 라이언 인형의 개수가 K개일 때까지  집합의 크기를 늘려본다
- 두 번째 인덱스부터 라이언 인형의 개수가 K개일 때까지 집합의 크기를 늘려본다
- ... 이렇게 Brute-Force하게 찾으면 무조건 해가 나온다

**[최적화]**

- 이것보다 더 빠르게 할 수 있는 방법은 뭐가 있을까?
- NlogN방법이 존재한다
- 먼저 누적합 배열이 필요하다
- 그리고 길이 T가 가능하다고 해보자
- T가 가능하다면 길이 N 누적합 배열에서 0번째 인덱스부터 +(T-1)한 곳까지의 라이언 인형 개수가 K보다 크면 가능한거다
- 이를 가능한 모든 인덱스를 시작으로 테스트 해본다
- 만약 하나라도 가능하면, 길이 T를 줄여서 또 테스트해본다
- 이렇게 T를 찾는데, 가장 작은 T를 구하면 된다
- 이 T는 이분 탐색으로 찾으면 된다
- 즉, 파라메트릭 서치를 이용하면 NlogN으로 최적해를 구할 수 있을 것이다

### 💡 핵심 로직
1. 라이언 인형에 대한 누적합 배열을 만든다.
2. left = K / right = N으로 두고, mid = (left + right) / 2 로하여 mid값에 대한 테스트를 진행한다.
3. 만약 해당 mid값이 가능하면, right = mid -1로 하고 그렇지 않다면 left = mid + 1을 해서 테스트가 가능한 가장 작은 mid값을 찾는다
	
### 📌 배운 점
- 문제 상황을 파라메트릭 서치가 가능한 형태로 변환하고, 파라메트릭 서치로 최적해를 구하는 연습을 했습니다.