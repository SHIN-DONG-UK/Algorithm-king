## 💡 BOJ 16139 - 인간-컴퓨터 상호작용 [[문제 링크](https://www.acmicpc.net/problem/16139)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `자료구조` |
| 사용 자료구조 | `누적 합` |
| 난이도 | 실버1 |

### ✅ 문제 설명
**[문제 요약]**

- 특정 문자열 S, 특정 알파벳 a, 문자열의 구간 [l, r]이 주어지면 S의 l번째 문자부터 r번째 문자사이에 a가 몇 번 나타나는지 구하라
- 같은 문자열을 두고 q번 질문을 할 거임

**[제약 사항]**

- 문자열 길이 <= 200,000
- 질문 수 <= 200,000

### 🔍 풀이 접근
- 매 반복마다 일일이 개수를 세면, 시간초과가 발생한다
- 왜냐하면 최악의 경우 쿼리 횟수 200,000 x 200,000
- 누적합의 확장이라고 생각해도 될거같다
- 0번째 인덱스부터 알파벳 개수를 누적해나간다
- 그니까 각 인덱스마다 26회의 반복을 수행하는거다
- 각 알파벳마다 누적합을 구해놓고, 단순히 쿼리돌리면 되는 문제이다
- S = abcdeabcde라고 하자 아래처럼 생각하면 된다
```
index | 0 1 2 3 4 5 6 7 8 9
a     |1 1 1 1 1 2 2 2 2 2
b     |0 1 1 1 1 1 2 2 2 2
c     |0 0 1 1 1 1 1 2 2 2
d     |0 0 0 1 1 1 1 1 2 2
e     |0 0 0 0 1 1 1 1 1 2
...

- Q1 : a 1 4 => S[a][4] - S[a][0] = 0
- Q2 : a 0 4 => S[a][4] - S[a][-1] = 1
- Q3 : a 0 5 => S[a][5] - S[a][-1] = 2
- Q4 : a 2 6 => S[a][6] - S[a][1] = 1
- Q5 : c 0 3 => S[c][3] - S[c][-1] = 1
...
```
- 이렇게 하면 되겠다
- 원래는 누적합배열에서 구간합을 빠르게 구하는 스킬인데, 구간 개수를 구할 때도 적용할 수 있나?

### 💡 핵심 로직
- 누적합을 활용해 쿼리 복잡도를 개선한다.

### 📌 배운 점
- 단순 정수의 누적합을 구해 구간합을 구하는 쿼리가 아니라, 각 알파벳 등장 횟수의 누적합을 만들어 쿼리를 빠르게 처리하는 응용을 이해했습니다.
