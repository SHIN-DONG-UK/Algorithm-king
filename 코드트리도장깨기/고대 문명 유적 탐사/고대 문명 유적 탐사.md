# 1. 이해

```
[맵]
- 5 x 5
	- 1 ~ 7로 구분

[탐사 진행]
- 3 x 3 격자 선택
- 시계 방향 90도, 180도, 270도 회전
- 우선순위
	1. '유물 1차 획득' 가치 최대화
	2. 회전 각도가 가장 작은 방법
	3. 회전 중심 좌표의 열이 가장 작은 구간
	4. 행이 가장 작은 구간

[유물 획득]
- 유물 1차 획득
	- 상하좌우로 인접한 같은 종류의 유물 조각은 서로 연결되어 있음
	- 3개 이상 연결된 경우, 조각->유물 그리고 사라짐
	- 유물의 가치는 모인 조각 개수

- 새로운 조각 생성
	- 벽면에 써 있는 숫자
	- 채우는 방법
		1. 열 번호가 작은 순
		2. 열 번호가 같으면 행 번호가 큰 순
		3. 조각은 충분해서 부족한 경우는 없다고 가정

- 유물 연쇄 획득
	- 새로운 조각이 채워지고 나서 다시 3개 이상 연결되어 유물이 될 수 있음
	- 그럼 사라지고 다시 채워지게 됨
	- 이 과정은 유물이 안 생길 때가지 반복됨!
	
- 탐사 반복
	- 유물 연쇄 반응이 끝나고나면 1턴이 끝남
	- 위 과정을 K턴 반복

[출력]
- 각 턴마다 획득한 유물의 가치 총합을 출력하라
- 단, 아직 K번 턴을 진행하지 못했지만, 탐사 진행 과정에서 어떠한 방법을 사용하더라도
유물을 획득할 수 없었다면 모든 탐사는 즉시 종료 && 아무 것도 출력 x

[입력]
- K, M (1 <= K <= 10, 10 <= M <= 300)
- 맵
- 벽면에 적힌 M개의 유물 조각 번호 -> 자료구조 큐를 사용해야 겠다
```

# 2. 설계

```
두 가지로 나누어서 구현해보자
1. 탐사 진행
	- 유물 1차 획득 가치를 최대화 하기 위해 인접한 블록 탐색이 필요 -> BFS
	- 유물 1차 획득 가치 최댓값을 찾기 위해 모든 좌표를 찾아봐야 함 -> 2중 for문
		- 우선순위에 따라 값이 업데이트 되기 위해, for문을 잘 구성해야 함
			- 가장 바깥 for문에 회전을 두어서 일단 90도 회전에서 최댓값을 찾아야 함
			- 그 다음 for문에 열 탐색을 두어서 일단 작은 열에서 최댓값을 찾아야 함
			- 가장 안쪽 for문은 행 탐색을 두어서 최댓값을 찾음
	
	[필요 함수]
	- 90도 회전 함수
	- 회전을 원상복구하는 함수 -> 원상복구하지말고 그냥 원본 맵 계속 복사해서 쓰자
	- BFS 함수
	- 2중 for문 겉 껍데기 함수

	[탐사 진행 종료]
	- 탐사 진행이 끝나면 점수를 획득하고 해당 유물은 사라짐
	- 그럼 어떤 조각이 사라지는지를 알아야 함 -> 좌표와 회전각도를 기록해 놓으면 최대 찾고
	원본 맵에 탐사해서 원본 맵에 빵꾸 뚫는거 적용하면 됨

2. 유물 획득
	- 탐사 진행이 종료되면 원본 맵은 빵꾸뚫려있음
	- 여기를 채우고 다시 블록 탐색
	- 블록 탐색이 안될 떄까지 반복
	- 이거는 원본 맵에서 계속 진행해도 됨
	
	[유물 연쇄 획득 종료]
	- 유물 연쇄 획득이 종료되면 턴 끝난거임
	- 이제 이걸 K번 반복하면 됨
```