# 1. 이해

```
[문제 요약]

- 산타는 공장에서 순서대로 q개의 명령에 따라 일을 진행한다
- 일의 종류는 다음 5개

    1. 공장 설립
        - 선물 공장에 m개의 벨트를 설치하고, 각 벨트 위에 정확히 n/m개의 물건들을 놓아 총 n개의 물건을 준비
        - 각 물건에는 고유한 번호(id)와 무게(w)가 적혀있다
        - 번호는 상자마다 다르지만, 무게는 같을 수 있음
    
    2. 물건 하차
        - 산타가 원하는 상자의 최대 무게인 w_max가 주어짐
        - 1번부터 m번까지 순서대로 벨트를 보며 각 벨트의 맨 앞에 있는 선물 중 해당 선물의 무게가 w_max이하라면 하차를 진행하고, 그렇지 않다면 해당 선물을 벨트 맨 뒤로 보낸다
        - 벨트에 있던 상자가 빠지면 한 칸씩 앞으로 와야 함
    
    3. 물건 제거
        - 산타가 제거하기를 원하는 물건의 고유번호 r_id가 주어짐
        - 해당 고유번호에 해당하는 상자가 놓인 벨트가 있다면, 해당 벨트에서 상자를 제거하고 이에 따라 뒤에 있던 상자들은 앞으로 한 칸씩 내려온다
    
    4. 물건 확인
        - 산타가 확인하기를 원하는 물건의 고유 번호 f_id가 주어짐
        - 해당 아이디가 있는 벨트가 있다면 해당 벨트의 번호를 출력하고, 없으면 -1을 출력
        - 단, 상자가 있는 경우, 해당 상자와 뒤에 있는 모든 상자를 전부 맨 앞으로 가져온다. 순서 그대로 가져와야 한다
    
    5. 벨트 고장
        - 고장이 발생한 벨트의 번호 b_num이 주어짐
        - b_num번 째 벨트에 고장이 발생하면 해당 벨트는 다시 사용할 수 없게 되고, b_num 벨트의 바로 오른쪽 벨트부터 순서대로 보며 아직 고장나지 않은 최초의 벨트 위로 b_num벨트에 놓여 있던 상자들을 앞에서부터 순서대로 하나씩 옮긴다
        - 만약 m번 벨트까지 봤는데도 고장나지 않은 벨트가 없다면 다시 1번부터 순서대로 벨트를 확인(모든 벨트가 고장나는 일은 없다)
        - 만약 이미 b_num이 이미 망가져있었다면 -1을, 그렇지 않았다면 정상적으로 고장을 처리했다는 뜻으로 b_num을 출력


[제약 사항]

- 명령의 수 q <= 100,000
- 상자의 수 n <= 100,000 (n은 항상 m의 배수)
- 벨트의 수 m <= 10
- 상자의 ID <= 10억
- 상자의 무게 W <= 10억
```

# 2. 설계

```
[나이브한 생각]

- 벨트를 나타내는 자료구조로 deque를 사용하면 구현이 쉽고 빠르게 가능해보인다
- 근데 시간복잡도가 10만이면 무조건 10만x10만=100억으로 시간초과난다
- 배열에 그냥 넣어놓고 start index를 둬서 시작점을 항상 변하게 하면 되지 않나? 어차피 start만 중요하지 그 뒤로 순서는 계속 유지되야 하잖슴
- 아 아니네, 계속 바뀌면서 섞일 수 있음
- linked-list를 쓰는게 맞나?
- linked-list를 쓰면 2번은 일단 빠르게 수행 가능
- 3번은 링크드 리스트라서 순서대로 계속 찾아야 함 -> 10만번 가능
- 4번 물건 확인도 일단 원하는 id로 가려면 최악의 경우 10만번 이동해야 함
- 아 접근은 배열로 하고, 얘네들의 관계는 링킹하는식으로 해야 하나?
- 링크드 리스트로 잘 구현하면 시간복잡도 매우 작을듯

[설계]

- 일단 각 벨트마다 Head와 Tail을 기록하고 있는거임
- 그리고 상자끼리 처음에 링킹을 해놓음
- Head와 Tail도 기록해둠
- 상자 정보는 배열에 저장하고, 이놈의 주소값을 계속 사용할거임
- 1번은 n개의 상자정보를 배열에 저장하고 m개의 벨트에 대해 링킹과 Head Tail을 초기화하는 과정임

- 2번은 Head를 돌면서 w_max 조건에 따라 정리하는 과정임
    - 만약 조건에 안맞으면 Head에 Head->next를 저장하고 원래 Head는 Tail로 가야 함
    - 이때 prev와 next를 잘 초기화해줘야 함

- 3번은 고유번호에 해당하는 배열 인덱스 Map으로 해당 상자를 찾아감
    - 그리고 이놈을 삭제하는 과정을 진행함 -> double linked list 삭제

- 4번은 id -> 인덱스 Map으로 해당 상자를 찾음
    - 그리고 Head와 Tail을 바꾸는 과정임

- 5번도 Head와 Tail을 바꾸는 과정이며, prev와 next를 잘 업데이트해야 한다

[자료구조]

- 상자 정보 구조체
    - ID
    - W
    - *prev
   - *next
  - belt
   - is_removed

- 상자 정보를 저장하는 배열
    - 최대 10만

- 상자 ID -> idx Map
    - 상자 ID가 최대 10억이므로, unordered_map으로 해싱한다

- Head와 Tail
    - 각 벨트마다 Head와 Tail을 둔다
    - 최대 10

- 벨트 망가짐 여부
    - bool 배열로 선언
    - bnum으로 바로 접근가능하게 배열로
    - 최대 10

[알고리즘]

1. 공장 설립
    - 벨트 개수 m을 저장
    - n개의 물건 정보를 입력
    - outer-loop m
	- Head를 초기화
        - inner-loop n/m
	    - loop 동안 prev와 next를 초기화한다
	- Tail을 초기화

2. 물건 하차
    - Head를 돈다
    - 현재 벨트의 Head가 w_max이하라면 해당 상자의 next를 Head로 저장한다
   - 해당 상자의 next를 nullptr로 바꾼다
    - 해당 상자의 is_removed 를 true로 한다
    - 해당 상자의 next의 prev는 nullptr로 바꾼다
    - 무게를 임시 변수에 더한다

3. 물건 제거
    - id->idx Map을 통해 상자 정보를 얻는다
    - 만약 삭제되었으면 -1을 리턴한다
    - 해당 상자의 prev의 next는 해당 상자의 next로 한다
    - 해당 상자의 next의 prev는 해당 상자의 prev로 한다
    - 해당 상자의 prev와 next는 nullptr로 초기화한다
    - 해당 상자의 is_removed를 true로 한다
    - 이게 Head이거나 Tail이면 조금 다르게 해야할듯?

4. 물건 확인
    - id -> idx Map을 통해 상자 정보를 얻는다
    - 삭제가 안됐으면 해당 벨트 번호를 출력한다
    - Tail의 next를 Head로한다
    - Head의 prev를 Tail로 한다
    - 그리고 해당 상자를 Head로 한다

5. 벨트 고장
    - b_num번째 벨트를 고장처리한다
    - 그리고 b_num부터 오른쪽으로 돌면서 처음으로 고장이 나지 않은 벨트를 찾는다
    - b_num의 Head의 prev를 찾은 벨트의 Tail로 한다
    - 찾은 벨트의 Tail의 next는 b_num 벨트의 Head로 한다
    - 찾은 벨트의 Tail을 b_num의 Tail로 한다
```