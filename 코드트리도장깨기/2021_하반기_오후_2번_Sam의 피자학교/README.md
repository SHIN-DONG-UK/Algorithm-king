# 1. 이해

```
[문제 요약]

- 처음 피자 도우는 평평하지 않으며 각 도우 위치에 대한 밀가루 양은 배열로 주어진다
- 완벽한 피자 도우를 만드는 과정은 다음과 같다
  1. 밀가루 양이 가장 작은 위치에 밀가루 1만큼 더 넣어준다
    - 단, 가장 작은 위치가 여러 개라면 모두 넣는다

  2. 도우를 말아준다
    - 도우를 말 때 바닥에 있는 밀가루보다 위에 있는 밀가루의 너비가 더 넓으면 중단

  3. 도우를 꾹 눌러준다
    - 각 위치에 상하좌우로 인접한 두 밀가루의 양을 a,b라고 할 때, |a-b|를 5로 나누었을 때의 몫을 d라고 하자
    - a와 b 중 크기가 큰 값에 d를 빼주고, 크기가 작은 값에 d를 더한다
    - 모든 위치의 밀가루에서 진행되며 이 과정은 동시에 진행된다
    - 이 모양이 2차원 격자 위에 놓였다고 하자
    - 그럼 열이 작은 것부터, 같으면 행이 큰 것부터 순서대로 1차원 배열에 넣는다
    - 이렇게 되면 다시 도우가 1차원 배열로 쭉 펴진다

  4. 도우를 두 번 반으로 접는다
    - ㄹㅇ 두 번 반 접으면 됨

  5. 3을 한번 더 진행
    - 3번을 한 번 더 하면 됨

- 이렇게 1-5과정을 수행하는 것을 1회라고 했을 때, 각 위치의 밀가루 양의 최댓값과 최솟값의 차이가 k이하가 될 때까지 반복하려고 한다
- k이하가 되기 위한 최소 반복 횟수를 구하라

[제약 사항]

- 밀가루 양이 담긴 배열의 크기 n <= 100
- 최대 최소 차이 k <= 5
- 각 위치의 밀가루 양 <= 3,000
- 단, n은 4의 배수다
```

# 2. 설계

```
[설계]

- 각 단계별로 함수를 구현하면 된다

- 1번 과정은 1차원 배열을 돌면서 최솟값을 탐색한다
- 그리고 다시 배열을 돌면서 최솟값과 같은 위치의 밀가루에 +1한다

- 2번 과정은 2차원 격자에 값을 복사한다
- 처음에 1차원 배열의 0번 인덱스 값을 1번인덱스 위에 올리면서 시작한다
- 처음 접힌 반죽은 너비 1 높이 2다
- 두 번째 접힌 반죽은 너비 2 높이 2다
- 세 번째 접힌 반죽은 너비 2 높이 3이다
- 네 번째 접힌 반죽은 너비 3 높이 3이다
...
접을 때 너비와 높이가 같으면 높이가 1증가하고, 다르면 너비가 1증가한다
- 그리고 접어 올릴때마다 너비 x 높이에 해당하는 격자가 시계방향으로 90도 회전한다
- 타겟 인덱스는 2에서 시작
  - 2부터 반죽을 올린다
- 그 다음 타겟 인덱스는 높이만큼 더한다 == 4
  - 4부터 반죽을 올린다
- 반죽을 올릴 때 기존의 반죽들은 지우고 가야한다
...
- 반죽의 왼쪽 아래부터 행이 작아지는 순으로(outer-loop), 열이 커지는순(inner-loop)으로 탐색한다

- 3번 과정
  - 마지막으로 접은 반죽의 좌상단 좌표를 알 수 있나?
  - 거기서부터 끝까지 돌면서 빈곳은 넘어간다
  - 밀가루가 있는 칸에서 4방향 탐색하고 d구해서 next 배열에 기록하면 된다
  - 행이 큰 순으로, 열이 작은 순으로 for-loop을 돌면서 2차원 격자에 기록된 밀가루를 1차원 배열에 복사한다

- 4번 과정
  - 처음에 n / 2만큼 반대로 뒤집어서 n/2 ~ n의 위에 행에 복사한다
  - 두 번째로 n/2부터 n/2 + n/4까지 180도 회전해서 n/2 + n/4 ~ n위에 행에 복사한다

- 5번 과정
  - 3번 함수 호출한다
  - 마지막으로 접은 반죽의 열은 n/2 + n/4이다
  - 마지막으로 접은 반죽의 높이는 항상 4다
```