# 1. 이해

```
[문제 요약]

- 0에서 5사이의 숫자로 이루어진 n x n 크기의 격자가 있음
  - 0 : 빈 공간
  - 1 : 사무실
  - 2 : 에어컨이 왼쪽
  - 3 : 에어컨이 위쪽
  - 4 : 에어컨이 오른쪽
  - 5 : 에어컨이 아래쪽

- 에어컨이 사무실을 시원하게 하는 과정은 아래 3가지를 거친다
  1. 에어컨의 바람이 나와서 그림의 수만큼 공기를 시원하게 함
    - 단, 가는 방향에 벽이 있으면 전파가 진행되지 않음
      - 단, 에어컨이 놓여있는 자리에도 시원함이 생길 수 있음

  2. 시원한 공기들이 섞이기 시작
    - 시원한 공기들은 서로 인접한 칸들에 대해 시원함이 높은 곳에서 낮은 곳으로 (시원함의 차이 / 4)만큼 전파
    - 모든 칸에 대해 동시에 일어나며, 벽을 사이에 두고 있는 칸끼리는 전파되지 않음
  3. 외벽에 있는 칸에 대해서만 시원함이 1씩 감소

- 위 과정을 한 번 거치면 1분이 흐른다
- 이 사이클은 모든 사무실에서의 시원함이 전부 k이상이 될때까지 반복
- n x n 크기의 격자판의 상태와 m개의 벽에 대한 정보가 주어졌을 때, 모든 사무실의 시원함의 정도가 k이상이 되는 최초의 시간을 구하라


[제약사항]

- 격자 크기 n <= 20
- 벽 개수 m <= n x n
- 목표 시원함 k <= 1,000
- 100분이 넘는다면 -1을 출력
```

# 2. 설계

```
[설계]

- 모든 에어컨들이 일제히 시원함을 제공하는 로직이 필요하므로, 에어컨들을 배열에 저장하고 이 배열을 한 번 돌면서 run() 함수를 돌려야 한다
- 이를 위해 2차원 격자 정보를 받아서 1차원 배열에 에어컨들을 넣어놔야 한다
- 그리고 빈 공간과 사무실이 구분되어 있으므로 모든 사무실이 k이상 시원해졌는지 검사할 때 주의가 필요하다
    - 모든 사무실이 시원해졌는지 매번 루프를 돌아서 검사할 필요가 있을까?

- 벽 정보를 저장하기 위해, 위치와 방향정보를 같이 넣어놔야 한다
- (3,2)에 벽이 있는데, 어느 방향에 있느냐에 따라 전파가 달라지기 때문
    - 3차원 배열로 저장하면 될 것 같다

[자료구조]

-> 벽 정보 3차원 배열 필요
-> 에어컨을 담고 있는 배열 필요
-> 매번 시원함을 저장하는 2차원 배열 필요
-> 전파를 위한 next 배열 필요
-> 사무실 위치만 저장하는 vector 필요

[알고리즘]

에어컨 run() 함수
  - 에어컨 방향을 알아낸다
  - bfs로 run()을 구현하자
   - bfs의 loop에는 3가지가 있다
      - 현재 위치에서 에어컨 방향으로 직진(이 때 벽에 막히면 무효)
       - 현재 위치에서 에어컨 방향 왼쪽으로 직진 & 다음 위치에서 에어컨 방향으로 직진(이 때 벽에 막히면 무효)
    - 현재 위치에서 에어컨 방향 오른쪽으로 직진 & 다음 위치에서 에어컨 방향으로 직진(이 때 벽에 막히면 무효)
   - 이미 방문한 곳은 queue에 push 하지 않음
   - 다음 시원함이 0이면 queue에 push 하지 않음
   - queue의 Node가 위치랑 "시원함"을 갖고 있어야 함
   - next Node는 다음 위치랑 다음 시원함을 전달한다

시원함 spread() 함수
    - 시원함 저장 배열 n x n을 다 돈다
    - 0인 곳은 무시
    - 주변 4방향 탐색
        - 다음 칸이 현재 칸보다 작으면 각을 재본다
        - 차이 / 4을 next 배열에 더해준다
    - 현재 칸은 준 만큼 next 배열에 빼준다
    - n x n을 다 돌았으면 next 배열의 값을 시원함 저장 배열에 합쳐준다

시원함 decrease() 함수
    - 바깥쪽 시원함을 1 깐다
    - 0인 곳은 넘어간다
```