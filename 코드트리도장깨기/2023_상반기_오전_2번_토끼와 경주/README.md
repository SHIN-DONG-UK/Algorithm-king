# 1. 이해

```
[문제 요약]

- 토끼들이 점수를 건 경주를 진행하려고 한다
- 경주에 관한 정보는 아래와 같다
(1) 경주 시작 준비
   - P마리 토끼가 N x M 격자에서 경주를 준비한다
    - 각 토끼에는 고유 번호가 있다
    - 한 번 움직일 시 꼭 이동해야하는 거리가 정해져 있다
    - i번 토끼의 고유 번호는 pid[i], 이동해야 하는 거리는 d[i]
    - 처음에 토끼는 모두 (1, 1)에 있다

(2) 경주 진행
    - 가장 우선순위가 높은 토끼를 뽑아 멀리 보내주는 것을 K번 반복한다
    - 우선순위는 (현재까지 총 점프 수가 적은 토끼 -> 현재 행 + 열 -> 행이 작은 토끼 -> 열이 작은 토끼 -> id가 작은 토끼) 순이다
    - 우선순위가 가장 높은 토끼가 i번 토끼라고 하자
        - 상하좌우 네 방향으로 각각 d[i]만큼 이동했을 때의 위치를 구한다
        - 이때 이동하는 도중 그 다음 칸이 격자를 벗어나게 되면 방향을 반대로 바꿔 한 칸 이동한다
         - 이렇게 구해진 4개의 위치 중 (행 번호+열번호가 큰 칸, 행 번호가 큰 칸, 열 번호가 큰 칸) 순으로 우선순위를 두었을 때 가장 우선순위가 높은 칸으로 이동
         - 이 칸의 위치를 (ri, ci)라고 할 때 i번 토끼를 제외한 나머지 P-1마리 토끼들은 전부 ri + ci만큼 점수를 동시에 얻는다

    - 이렇게 K번의 턴 동안 가장 우선순위가 높은 토끼를 뽑아 멀리 보내주는 것을 반복하게 되며, 이 과정에서 동일한 토끼가 여러 번 선택될 수 있다
    - K번의 턴이 모두 진행된 직후에는 (현재 서있는 행 번호 + 열번호, 행 큰, 열 큰, id큰) 순으로 우선순위를 두었을 때 가장 우선순위가 높은 토끼를 골라 S를 더해준다
     - 단, 이 경우에는 K번의 턴 동안 한 번이라도 뽑혔던 적이 있던 토끼여야 함

(3) 이동거리 변경
    - 고유번호가 pid인 토끼의 이동거리를 L배 해준다
    - 단, 계산 도중 특정 토끼의 이동거리가 10억을 넘지 않는다

(4) 최고의 토끼 선정
    - 각 토끼가 모든 경주를 진행하며 얻은 점수 중 가장 높은 점수를 출력



[제약 사항]

- 경주 진행 <= 2,000
- 이동거리 변경 <= 2,000
- 최고의 토끼 선정은 항상 마지막 명령으로만 주어진다
- 명령의 수 Q <= 4,002
- 격자 크기 N, M <= 100,000
- 토끼 수 P <= 2,000
- 토끼 고유 번호 <= 10억
- 토끼 이동거리 <= 10억
- 경주 진행 시 K번 <= 100
```

# 2. 설계

```
[나이브한 생각]

- 우선순위를 잘관리해야 하고, 경주 진행 시 다음 칸을 결정할 때 수식을 잘 작성해서 다음 칸을 빠르게 구할 수 있어야 한다
- 격자 내의 관계성이 필요한 경우는 없으므로, 격자를 관리하지 않아도 된다
- 고유 번호가 10억 이하라 unordered_map으로 관리한다
- 우선순위를 관리하는 PQ를 계속 유지하고 있을 필요가 있다

[자료구조]

- 토끼 구조체
      - id
    - dist
    - count
    - score

- 토끼 정보 배열
     - 토끼 구조체 배열

- id -> 토끼 정보 포인터
    - unordered_map

- 우선순위 큐
    -  (현재까지 총 점프 수가 적은 토끼 -> 현재 행 + 열 -> 행이 작은 토끼 -> 열이 작은 토끼 -> id가 작은 토끼) 순

[알고리즘]

1. init()
    - 격자 크기를 저장한다
    - 토끼 정보 배열에 저장한다
    - 토끼 정보 포인터를 unordered_map에 저장한다
    - 우선순위 큐에 토끼 정보 포인터를 삽입한다

2. go_race(int K, int S)
  - "후보 토끼"
     - S를 더해줄 토끼
       - 처음에는 "우선순위"가 가장 작도록 세팅한다

  - K번 루프를 돈다
        - 우선순위 큐에서 토끼를 뽑는다
        - 토끼의 다음 위치를 매 방향마다 구한다
            - 토끼가 이동하는 칸은 주기 함수를 띈다
            - 주기를 구하면, 토끼의 다음 칸을 알 수 있다
            - 주기는 격자의 크기의 두 배이다
            - 따라서 토끼의 (현재 위치 + 이동거리) % T를 하면 다음 칸이 나온다
            - 예를 들어 토끼의 현재 위치 y=3이라고 하고, d=17이라고 하자 그리고 주기 T=6이라고 하자
            - 토끼의 다음 y는 (3+17) % 6 = 2다
         - 만약 현재 방향에서 다음 위치가 기록된 것보다 "우선순위"가 높으면 갱신한다
            - 4방향을 돌아서 최종 다음 위치가 갱신되어 있다
            - 해당 칸으로 이동한다
             - 그리고 현재 토끼를 제외한 P-1마리 토끼의 점수를 (해당칸)만큼 업데이트 해야하는데, loop를 통해 업데이트하면 TLE가 날 가능성이 크다
             - 일단 루프로 업데이트한다고 해보자
         - 이제 해당 토끼가 "후보 토끼"보다 "우선순위"이면 갱신한다
   - "후보 토끼"에 S를 더한다
    - 시간복잡도 : K·P·logP -> K=100이고 P=2000이면 위험하긴 함(토끼 점수 갱신 과정이 복잡함)

3. change_dist(int pid, int L)
   - unordered_map으로 토끼 포인터를 얻는다
    - 토끼의 이동거리를 L배한다
    - 시간 복잡도 O(1)

4. get_best()
    - 그냥 P번 돌면서 토끼 정보 배열에서 점수 제일 큰 값 출력하면 됨
    - 시간 복잡도 O(P)



[설계 오류]

- 다음 칸 계산이 잘못됐음
- 현재 위치는 신경쓰지 않고, dist를 주기로 나눠줌
- 그리고 나머지만큼 해당 방향으로 이동하는거임
- 근데 여기서 또 나머지만큼 일일이 이동할 필요가 없음
- 예를 들어 dist = 23이라고 하자
- dist % 6 = 5임
- 현재 위치에서 5칸 갈거임
- 근데 y = 1이라고 하자
- 1칸 이동해서 끝에 보냄(방향 전환)
- 4 남음
- N만큼 이동해서 끝에 보냄(방향 전환)
- 4 - N = 1남음
- 현재 방향으로 1보냄 -> 최종 위치

- 이런 식으로 끝으로 보내고 방향 전환하고, 남은 거리 만큼 해당 방향으로 계속 해주면 됨

- 끝에서는 두 번 왕복할 수 있음

```

# 3. 디버깅
- 주기 계산이 잘못됨
  - 2 * N이 아니라 2 * (N-1)임
  - 혼자 설계하면서 오해한듯

- 경계부분에서 예외처리가 필요함
  - 그래서 left, right, upper, lower 변환 함수를 만들어 놓고 경계인지 먼저 체크하도록 수정