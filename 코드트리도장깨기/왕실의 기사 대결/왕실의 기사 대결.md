# 1. 이해

```
[체스판]
- L x L
- 좌상단(1, 1)
- 빈칸
- 함정
- 벽
- 체스판 밖도 벽으로 간주

[왕실의 기사]
- (r, c)를 좌상단으로 하여 h x w의 직사각형 형태를 띔
- 각 기사의 체력 k

[기사의 이동]
- 상하좌우 중 하나로 한 칸 이동
- 이동 하려는 위치에 다른 기사가 있다면 그 기사도 함께 연쇄적으로 한 칸 밀려남
- 또 그 옆에 기사 있으면 밀려남
- 근데 이동하려는 방향의 끝에 벽이 있다면 모든 기사는 이동할 수 없음
- 체스판에서 사라진 기사에게 명령을 내리면 아무런 반응이 없음

[대결 대미지]
- 명령을 받은 기사가 다른 기사를 밀치게 되면, 밀려난 기사들은 피해를 입음
- 각 기사들은 이동한 곳에서 w x h 안에 놓인 함정의 수만큼 피해를 입게 됨
- 각 기사마다 피해만큼 체력이 깎이고, 현재 체력 이상의 대미지를 받을 경우 체스판에서 사라짐
- 단, 명령을 받은 기사는 피해를 입지 않음
- 단, 기사들은 모두 밀린 이후에 대미지를 입게 됨 -> 그니까 벽이 없는거 확인하고 계산하라고
- 밀렸더라도 함정 없으면 피해 없음
-------------------------------------------------------------------------------------
[출력]
- Q 번에 걸쳐 왕의 명령이 주어졌을 때, Q 번의 대결이 모두 끝난 후 생존한 기사들이 총 받은
대미지의 합을 출력하라

[입력]
- L, N, Q
	- L : 체스판 크기 MAX_L 40
		- 0 : 빈칸
		- 1 : 함정
		- 2 : 벽
	- N : 기사의 수 MAX_N 30
		[r c h w k]
			- r : y
			- c : x
			- h : 높이
			- w : 너비
			- k : 체력
	- Q : 명령의 수
		[i d]
			- i : 타겟(i번 기사) 1~N
			- d : 방향 0 1 2 3(상 우 하 좌)
			
```

# 2. 설계

```
<체스판>
- 좌상단 (1, 1)
- 0 : 빈칸
  1 : 함정
	2 : 벽
- 체스판 밖도 벽
- 그래서, L+2 크기로 선언하고 벽으로 맵을 둘러싸자
- 그럼 경계조건 판단이 쉬워짐

<왕실의 기사>
- struct Knight
	int y
	int x
	int h
	int w
	int k
	int num

<기사의 이동> -> CheckKnight(), MoveKnight()
- 맵과 기사 배열을 같이 쓰자 -> 그러면 편함
- 서로 update를 잘 해주자
- 기사가 움직일 수 있는지 검사하는 함수를 만들자
- 이 함수는 BFS탐색하면 된다
- 그리고 이동이 가능하면, 실제로 이동하는 함수를 만들자
- 어떤 기사를 움직일지 어떻게 아는데?
	=> 방문처리 했짢아!
- 다음 칸을 탐색할 때, dir방향만 탐색하면 되는데 근데 기사가 직사각형 형태다 보니, 고려해야 할
조건들이 몇 가지 있다
	1. 자기자신인 경우 -> cut
	2. 벽인 경우 -> return false
	3. 빈칸이나 함정 -> 그냥 넘어가
	4. 다른 기사 -> 방문처리하고 큐에 넣어

<대결 대미지>
- 일단 이동을 다 끝마치고 대미지를 입는다
- 체력이 0이하인 애들은 맵에 다시 반영하지 말 것
- 얼마나 깎이는 지는 자기 자신의 범위안에 있는 함정 수 세아리면 됨

<메인 함수>
- Input() 받고
- CheckMove() -> return false -> 다음 명령
							-> return true -> MoveKnight() -> 대미지 기록

```

# 3. 주의

```
- 방문처리가 되었다 -> 생존
- 방문처리가 안되었다 -> 생존은 아님
- 그래서 기사 이동하고 맵에 반영할 때, 예전에 탈락한 기사가 다시 맵에 등장하는 오류가 발생할 수
있음
```