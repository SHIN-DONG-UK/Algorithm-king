# 1. 이해

```
[문제 요약]
- n x n 격자판
- 격자판은 흰색, 빨간색, 파란색 중 하나의 색을 갖는다
- 말은 총 k개가 주어짐
  - 위치
  - 번호
  - 방향 (상하좌우)
- 턴 한 번동안 1번 말부터 k번 말까지 규칙대로 순서대로 움직임
- 말을 옮기는 규칙
    - 말이 이동하려는 칸이 흰색인 경우에는 해당 칸으로 이동
        - 이동하려는 칸에 말이 이미 있는 경우에는 해당 말 위에 이동하려는 말을 올려둠
        - 이미 말이 올려져 있는 상태에도 말을 올릴 수 있음
    - 이동하려는 칸이 빨간색인 경우에는 해당 칸으로 이동하기 전 순서를 뒤집음
        - 이후 해당 칸에 말이 있는 경우에는 흰색 칸과 같이 그 위에 쌓아둠
    - 이동하려는 칸이 파란색일 경우에는 이동하지 않고 방향을 반대로 전환한 뒤 이동
        - 만약 반대 방향으로 전환한 뒤 이동하려는 칸도 파란색이라면 방향만 반대로 전환한 뒤 이동하지 않음
        - 여러 말이 쌓여있는 경우 이동하려는 말만 방향을 반대로 바꿔야 함에 유의
    - 격자판의 범위를 벗어나는 이동일 경우 파란색으로 이동하려는 것과 똑같다

- 게임이 진행되는 동안 아직 한 턴이 다 끝나지 않은 경우더라도 말이 4개 이상 겹쳐지는 경우가 생긴다면 그 즉시 게임을 종료

- 게임이 종료되는 순간의 턴 번호롤 구하라

[제약 사항]

- 0 : 흰색
- 1 : 빨간색
- 2 : 파란색
- 격자판 크기 4 <= n <= 12
- 말의 개수 4 <= k <= 10
- 방향 d -> 1 or 2 or 3 or 4
    - 1:우/2:좌/3:상/4:하
- 같은 칸에 두 개의 말이 입력으로 주어지는 경우는 없다
- 답이 1000보다 크거나 불가능한 경우 -1을 출력
```

# 2. 설계

```
[설계]
- 일단 1번 말부터 k번 말까지 순서대로 이동해야 하므로, 말의 정보를 연속된 배열에 저장할 필요가 있다
- 말끼리 순서를 갖고 연결되어야 하므로, 링킹을 고려해볼 수 있다 혹은 단순히 vector로 관리해도 ㄱㅊ을 것같다
- 말 구조체
    - 위치
    - 방향
    - 순서


- 2차원 vector를 둔다
- 다음 칸이 흰색이면 현재 순서대로 push_back한다 (뒤집고 push_back)
- 다음 칸이 빨간색이면 뒤집어서 push_back한다(그냥 push_back하면 순서가 뒤집힘)
- 다음 칸이 파란색이면 방향을 반대로 꺾은 다음에 이동
    - 반대 칸도 파란색이면 아무 것도 하지 않음
- 격자의 외벽도 파란색으로 표시한다
```