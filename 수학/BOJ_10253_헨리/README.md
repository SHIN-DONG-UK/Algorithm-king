## 💡 BOJ 10166 - 관중석 [[문제 링크](https://www.acmicpc.net/problem/10166)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `수학` |
| 사용 알고리즘 | `유클리드 호제법` |
| 난이도 | `실버1` |

### ✅ 문제 설명
**[문제 요약]**

- 1보다 작은 분수를 여러 개의 서로 다른 단위분수의 합으로 표현할 수 있다
- 단위분수 = 분자가 1인 분수
- 헨리식 표현법 = 1보다 작은 분수를 여러 개의 서로 다른 단위분수의 나열
- 주어진 분수의 헨리식 표현법을 구하는 간단한 방법
   - a/b에서 a/b >= 1/x1인 가장 큰 1/x1을 계산
   - 그리고 a/b - 1/x1 >= 1/x2인 가장 큰 1/x2를 계산
    - ...
   - 나머지가 남지 않을 때까지 반복
   - 이 무한루프는 항상 종료됨이 보장되고, 항상 존재함이 보장됨

- 1보다 작은 분수 a/b가 주어졌을 때 마지막 단위 분수의 분모를 출력하라

**[제약 사항]**

- 입력은 T개의 테스트 케이스로 구분됨
- a와 b는 서로소이고, 1 <= a < b <= 10,000
- 분모의 크기는 2^31보다 작다

### 🔍 풀이 접근
- 일단 알고리즘은 주어졌고, 이걸 그대로 구현하면 된다
- 가장 큰 1/x1을 먼저 찾아야 하니, 가장 작은 x1을 찾는 것과 같다
- 그리고 V = a/b - 1/x1
- V >= 1/x2인 x2를 또 찾는다
- 또 V -= 1/x2
- 만약 V가 0이면 루프를 종료한다
- 그리고 마지막 x를 출력한다
- 그런데 가장 작은 x를 찾기 위해 seqential search를 하는게 바람직한가?
- 그건 아니다. 왜냐하면 x가 될 수 있는 범위는 2 <= x <= 2^31이기 때문이다
- 따라서 반드시 시간초과를 받는다
- 어차피 부등식을 만족하는 정수를 찾는거라 이분탐색하면 된다
- 단, 분수 비교를 해야하고, 이를 위해 gcd가 필요하다

### 💡 핵심 로직
- 만약 a/b >= 1/x이면, 왼쪽 범위를 탐색한다
- 만약 a/b < 1/x이면, 오른쪽 범위를 탐색한다

- 두 분수를 비교하기 위해 두 분모의 gcd를 구한다
- 공통분모는 gcd x (b/gcd) x (x/gcd)이다
- a/b의 새로운 분자는 a x (x/gcd)이다
- 1/x의 새로운 분자는 b/gcd이다

- 그래서 a x (x/gcd) >= b/gcd이면, 왼쪽 범위를 탐색한다
- 아니면, 오른쪽 범위를 탐색한다
- 그래서 조건을 만족하는 최소 x를 찾는다


- 이제 이걸 반영한다
   - 공통분모를 구한다
   - t = a x (x/gcd) - b/gcd를 한다
   - 공통분모와 뺀 결과 사이의 gcd를 구한다
   - a = t / gcd
   - b = 공통분모 / gcd

- 만약 V = 0이면 루프를 종료한다

**[시간초과]**

- "a/b 보다 작지 않은 가장 작은 단위 분수의 분모는 b/a의 올림값이다"
- 이거 한 줄로 해결하는 문제임

### 📌 배운 점
- "a/b 보다 작지 않은 가장 작은 단위 분수의 분모는 b/a의 올림값이다"라는 사실을 알게 되었습니다.
- 알고리즘적으로 문제를 해결하면 시간초과이지만, 수학식을 활용하면 O(1)만에 문제를 해결할 수 있음을 상기했습니다.