## 💡 BOJ 1011 - Fly me to the Alpha Centauri[[문제 링크](https://www.acmicpc.net/problem/1011)]

| 항목 | 내용 |
|------|------|
| 문제 유형 | `수학` |
| 사용 알고리즘 |  |
| 난이도 | `골드5` |

### ✅ 문제 설명
**[문제 요약]**

- 이전에 k만큼 이동했다면, 현재 이동할 수 있는 거리는 k-1 or k or k+1
- 처음 이동할 때 -1, 0, 1만큼 이동이 가능한데, -1과 0은 의미가 없으므로 사실상 1만큼 움직일 수 있음
- 그럼 두 번째 이동에서는 0, 1, 2만큼 움직일 수 있음
- 두 번째 이동에서 2만큼 움직였다면, 세 번째 이동에서 1, 2, 3만큼 움직일 수 있음
- x지점에서 y지점까지 최소한의 이동 횟수로 이동하려고 함
- 단, y지점에 도착하기 바로 직전의 이동거리는 반드시 1이어야 함

**[제약 사항]**

- 테스트케이스 개수 T가 주어짐
- 각 테케에 대해 현재 위치 x와 목표 위치 y가 정수로 주어짐
- 0 <= x < y < 2^31

### 🔍 풀이 접근
- 나중에 1칸을 이동해서 도착해야 하니, 속도를 줄여줘야 한다
- 1 2 3 4로 갔다가, 어쨌든 4 3 2 1 이렇게 줄여서 와야한다는 말
- 계속 증가시킬 수 없다는 뜻
- 일단 무조건 최고점을 찍고 내려오는 것이 기본 뼈대임
- 여기서 최적값은 그리디하게 결정됨
- 한 칸씩 이동하면서 2번 쓰일 수 있다고 가정한다

### 💡 핵심 로직
- 이동해야 하는 거리 `dist`가 12라고 하자
- 왕복을 고려해 1 * 2를 써본다
- 2 * 2를 써본다
- 3 * 2를 써본다
- 나머지가 0이므로 최적이다
- 1 2 3 3 2 1

- `dist`가 9라고 하자
- 1 * 2 -> rem(7)
- 2 * 2 -> rem(3)
- 3 * 2는 안되고 3 * 1은 됨 -> rem(0) -> 최적
- 1 2 3 2 1

- `dist`가 22라고 하자
- 1 * 2 -> rem(20)
- 2 * 2 -> rem(16)
- 3 * 2 -> rem(10)
- 4 * 2 -> rem(2)
- 5 * 2 나 5 * 1이 안되니까 여기서 멈추고, 나머지가 존재하므로 개수를 +1 더한다
- 1 2 3 4 4 3 2 2 1

### 📌 배운 점
- 문제 구조상 숫자가 두 번 쓰여야만 한다는 sub 조건을 찾아내고, 이를 이용해 문제에 맞게 구현하는 연습을 했습니다.