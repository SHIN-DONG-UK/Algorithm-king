# 1. 이해

```
- N x N 크기 -> 1칸에 최대 한 마리 존재

- M마리 물고기
    - 크기(자연수)
    
- 아기상어 1마리
    - 크기(자연수), 초기=2
    - 1초에 상하좌우 한 칸 씩 이동
    - 자기보다 '큰' 물고기 칸은 갈 수 없음
    - 자기보다 '작은' 물고기를 먹을 수 있음
    - '같은' 크기는 먹을 순 없지만, 지나갈 순 있음
    - [이동 규칙]
		    1. 더 이상 먹을 수 있는 물고기가 공간에 없다면 help
		    2. 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 감
		    3. 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기 ㄱ
		        - 거리 : 아기상어위치 -> 물고기 위치 지나야하는 칸 개수
		        - 거리가 같다면? 1. 가장 위 2. 가장 왼쪽
    - [먹었다]
	    - 상어 크기만큼의 개수의 물고기를 먹었을 때, 상어 사이즈 +1
	    - 물고기칸 빈칸
	    - 먹는 시간은 소요되지 않음

[출력]
- 공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하라
-> 더 이상 먹을 수 없을때까지 반복하라

[입력]
- N : (2 <= N <= 20)
- 맵
		0 : 빈칸
		1,2,3,4,5,6: 물고기&&크기
		9 : 아기 상어
```

# 2. 설계

```
- 일단 아기 상어 위치를 얻는다
	-> 처음에 2중 for loop 돌면서 맵 상에서 9를 찾는다
	-> 이때 9 위치를 얻고 맵 상에서 없애주는게 나중에 에러 발생 이유가 없다
	
- 가장 가까운 먹을 수 있는 물고기를 찾는다
	-> BFS + 조건문 처리
		못 지나가는거 때문에 돌아가는 경우가 발생 -> 뭔가 flood fill이 이상해질 수 있	음 그래서 예외처리를 잘 해줘야 함
		가장 처음으로 물고기를 만났다고 해서 이 물고기를 먹으러 가면 안됨
		일단 먹을 수 있는 물고기를 다 표시하고, 찾아내야 함
	-> 없다? 종료
	-> 있다? ㄱ
```

# 3. 테스트 케이스

```
3
0 0 2
0 0 0
0 9 0
answer : 0
output : 0

3
6 6 6
6 6 6
6 9 6
answer : 0
output : 0

3
1 1 1
1 1 1
1 9 1
answer : 9
output : 9

3
1 3 0
3 1 0
1 0 9
answer : 6
```