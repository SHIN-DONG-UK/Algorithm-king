# 1. 이해

```
[원판]
- 반지름이 1, 2, ... N인 원판이 크기가 작아지는 순으로 바닥에 놓여 있음. 원판의 중심은 모두 같음
- 원판의 반지름이 i면, i번째 원판이라고 함
- 각 원판에는 M개의 정수가 적혀있음
- i번째 원판에 적힌 j번째 수의 위치는 (i, j)로 표현함
- (i, j)는 (i-1, j)랑 (i+1, j)랑 인접함
	- i가 1이거나 N일 때는 하나겠쬬?
	- 이 말은 원판이 달라도 j번째 숫자는 같은 라인에 있다는 말이겠쬬
- 같은 원판에서 서로 인접

[회전]
- 원판의 회전은 독립적으로 이루어 짐
- 원판을 아래와 같은 방법으로 총 T번 회전시키려고 함
- 원판의 회전 방법은 미리 정해져 있고, i번째 회전할 때 사용하는 변수는 xi, di, ki임
	1. 번호가 xi의 배수인 원판을 di 방향으로 ki칸 회전시킨다.
		di = 0 시계
		di = 1 반시계
	2. 원판에 수가 남아 있으면, 인접하면서 수가 같은 것을 모두 찾는다
		- 그러한 수가 있는 경우에는 원판에서 인접하면서 같은 수를 모두 지운다
			-> 지웠다는 표시를 하는 배열을 따로 만들어주면 오류가 발생할 일이 없음
		- 없는 경우에는 원판에 적힌 수의 평균을 구하고, 평균보다 큰 수에서 1을 빼고,
			작은 수에는 1을 더한다

[출력]
- 원판을 T번 회전시킨 후 원판에 적힌 수의 합을 구해보자

[입력]
- N, M, T
- N개 줄 -> 원판에 적힌 수
- T개 줄 -> xi di ki
```

# 2. 설계

```
[자료구조]
- 원판을 2차원 배열로 생각할 수 있다
- 위 아래 열끼리 인접하다
- 같은 행에서 좌우로 인접하다 이때는 Ring 자료구조를 생각하면 된다

[알고리즘]
회전
- 번호를 입력받으면 해당 행을 회전시키는 함수를 구현하면 된다
- O(N)의 시간복잡도면 충분하다
- 이때 k칸씩 옮겨야 하므로 결과를 저장해놓을 배열을 하나 더 만들면 된다

제거
- BFS를 사용해서 제거하면 되겠다
- 단, 상하좌우 탐색하는데 상하는 기존의 방식대로 하면 된다
- 좌우는 링 자료구조이므로 queue에 push할 때 주의한다
```
